{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"FlowPilot","text":"<p>Authorization-as-a-Service for Agentic Workflows</p> <p>FlowPilot is an authorization platform that handles complex access control for applications with AI agents, delegated authority, and multi-persona workflows.</p>"},{"location":"#what-is-flowpilot","title":"What is FlowPilot?","text":"<p>FlowPilot provides Authorization-as-a-Service for AI agents that need:</p> <ul> <li>Policy-based Authorization - Control what agents can do on behalf of users with declarative policies</li> <li>Persona-based Policies - Same user, different roles (traveler, agent, admin)</li> <li>Persona-based Delegation - Users delegate authority to agents or other users</li> <li>Privacy-First Design - No PII proliferation, minimal token claims</li> <li>Sovereign Deployment - Self-hosting and sovereignty as a first-class principle</li> </ul>"},{"location":"#how-it-works","title":"How It Works","text":"<ol> <li>You specify the ground rules in FlowPilot</li> <li>User tailor the rules depending on their risk appetite and trust</li> <li>Your AI agents, apps and microservices make REST API calls to FlowPilot for authorization decisions</li> <li>FlowPilot evaluates general policies, user-sepcific rules and delegation chains </li> <li>Your AI agents, apps and microservices comply with the decision</li> </ol>"},{"location":"#why-this-matters","title":"Why This Matters","text":"<p>Agentic AI automates decisions, trigger actions, and operates with a level of autonomy that was previously reserved for humans. Yet most authorization models still assume that access is static, implicit, and largely context-free.</p> <p>That assumption no longer holds.</p> <p>When software can act, the relevant question is no longer \u201cwho has access?\u201d, but who is acting, in which capacity, on whose behalf, and under which conditions. Without making those elements explicit, automation becomes difficult to trust, hard to audit, and risky to operate.</p> <p>Explainable authorization</p> <p>FlowPilot addresses this by treating authorization as a first-class concern. Actions are evaluated in context, combining identity, active persona, delegation scope, and policy constraints. If these elements do not align, the action does not proceed. There is no implicit privilege and no assumption that authority transfers automatically.</p> <p>Persona-based</p> <p>A central concept in FlowPilot is the persona. People do not merely authenticate; they act in a defined capacity. Personas represent explicit operating contexts and determine which actions are permitted. The same individual may act in multiple personas, but privileges never blend across them. Switching persona immediately changes what the system allows.</p> <p>Delegation to humans and AI</p> <p>Delegation is explicit and bounded. Permissions are granted deliberately, scoped by action, and revocable at any time. Delegations may be transitive where appropriate, but access is retained only while every link in the chain remains valid. Revocation takes effect immediately and predictably.</p> <p>Policy-as-code</p> <p>FlowPilot follows a policy-as-code approach. Authorization logic is declarative, versionable, testable, and reviewable in the same way as application code or infrastructure configuration. This allows governance to evolve transparently, supports automated regression testing, and makes behavior reproducible across environments.</p> <p>Decisions are enforced early and consistently and every decision is explainable in human terms, supporting auditability and operational clarity.</p> <p>Rather than introducing a proprietary control model, FlowPilot is designed to work alongside existing and emerging standards. It embraces standard concepts such as explicit policy evaluation, clear separation between decision and enforcement, and interoperability with identity and authorization ecosystems.</p>"},{"location":"#what-this-enables","title":"What This Enables","text":"<p>FlowPilot enables automation that remains accountable, collaboration without loss of control, and delegation that is safe by design. It supports clear governance, predictable revocation, and auditable decision-making across human and automated actors.</p> <p>Most importantly, it allows systems to act only when they should, and to make that decision explicit.</p>"},{"location":"#non-goals","title":"Non-Goals","text":"<p>FlowPilot is not intended to replace identity providers, authentication mechanisms, or directory services. It does not attempt to be a general workflow engine or a UI framework.</p> <p>FlowPilot is also not an ontology-definition framework. Unlike initiatives such as ODRL and IDSA, it does not attempt to define or standardize domain-specific vocabularies, sector ontologies, or semantic models of consent, assets, or relationships. The creation and governance of such ontologies is intentionally left to sectors, standards bodies, and domain communities where it belongs.</p> <p>Instead, FlowPilot focuses on a complementary problem: turning declarative policy models into operational, real-time authorization decisions.</p> <p>FlowPilot is designed to consume externally defined policy representations and compile them into executable authorization rules that can be evaluated deterministically at runtime. Its scope is the enforcement layer: evaluating personas, delegation chains, scopes, constraints, and context efficiently and explainably when an action is requested.</p> <p>In other words, FlowPilot does not seek to define what policies should mean across industries. Instead, FlowPilot focuses narrowly on one problem: making authorization decisions explicit, explainable, and enforceable in systems where actions matter and with a model that is easy to grasp and maintain. And doing this safely, consistently, efficiently and at scale in real systems.</p>"},{"location":"#multiple-policies-one-platform","title":"Multiple Policies, One Platform","text":"<p>FlowPilot supports multiple authorization policies side-by-side:</p> <ul> <li>Travel Policy - Autonomous booking with cost, risk, and lead time constraints</li> <li>Nursing Policy - Healthcare workflows with certification and patient load limits</li> <li>Custom Policies - Define your own with typed attributes and validation rules</li> </ul> <p>Policies are automatically selected based on resource type or explicit hints, with manifest-driven configuration for attributes, defaults, and validation.</p>"},{"location":"#the-travel-booking-metaphor","title":"The Travel Booking Metaphor","text":"<p>The concrete domain used is travel booking, but this is deliberately a metaphor for a generic \"workflow execution\" problem involving users, agents, and delegated authority.</p> <ul> <li>Trips / Itineraries are workflows</li> <li>Booking steps are workflow items</li> <li>Travelers can delegate actions to travel agents and AI agents</li> <li>Auto-execution preferences drive policy-driven constraints</li> </ul> <p>This maps cleanly to other domains:</p> <ul> <li>Medical record handling - Role-based access with patient consent and caring relationships</li> <li>Case management - Workflow delegation between case workers</li> <li>Financial approvals - Multi-level approval workflows, power of attorney, custody and mandates</li> <li>Enterprise automation - AI agents executing tasks within policy constraints</li> <li>Agent-based task execution - Autonomous agents with user-defined limits</li> </ul>"},{"location":"#why-not-just-use-oauthoidc","title":"Why Not Just Use OAuth/OIDC?","text":"<p>OAuth/OIDC handles authentication (who are you?), but FlowPilot handles authorization (what can you do?):</p> <ul> <li>OAuth: \"This is Alice\"</li> <li>FlowPilot: \"Alice (as a traveler) can delegate to Agent-X, who can auto-book if risk &lt; 50 and consent = true\"</li> </ul> <p>FlowPilot integrates with your auth provider (Firebase, Auth0, Keycloak, etc.), not instead of it.</p> <p>FlowPilot implements a three-tier token architecture that separates authentication from authorization:</p> <ol> <li>ID tokens (from your IdP) - Contain user PII, used client-side for UI display only</li> <li>FlowPilot access tokens - Pseudonymous tokens (UUID only), used for all backend API calls  </li> <li>Service tokens - For internal service-to-service communication</li> </ol> <p>When your app authenticates a user with the Identity Provider of your choice (Firebase/Auth0/etc.) you exchange the id-token for a pseudonymous FlowPilot access-token via the <code>/v1/token/exchange</code> endpoint. This access-token contains only the user's UUID (<code>sub</code>) with zero PII, preventing personal information from proliferating across your backend services.</p> <p>Personas (business roles) are passed as request parameters selected by the user, not embedded in tokens. This allows users to switch personas without re-authentication and prevents token bloat. The combination of a persona <code>title</code> and the user's <code>sub</code> uniquely identifies the persona record of the user.</p>"},{"location":"#quick-links","title":"Quick Links","text":"<ul> <li> <p> Integrate with Your App</p> <p>Add FlowPilot authorization to your web or mobile app</p> <p> Integration Guide</p> </li> <li> <p> API Reference</p> <p>Explore the REST APIs with interactive documentation</p> <p> API Docs</p> </li> <li> <p> Understanding Personas &amp; Delegation</p> <p>Learn how multi-persona auth and delegation work</p> <p> Concepts</p> </li> <li> <p> Writing Policies</p> <p>Create custom authorization policies for your use case</p> <p> Policy Guide</p> </li> </ul>"},{"location":"#key-features","title":"Key Features","text":""},{"location":"#policy-driven-authorization","title":"Policy-Driven Authorization","text":"<ul> <li>Declarative policies in OPA/Rego</li> <li>Multi-policy architecture - Dynamic policy selection per request</li> <li>Manifest-driven configuration - Declarative policy metadata with typed attributes, no coding</li> <li>Policy routing - Automatic selection based on resource type or explicit hints</li> <li>Explainable authorization decisions with structured reason codes</li> <li>AuthZEN protocol compliance for standardized authorization requests</li> </ul>"},{"location":"#persona-based-policies","title":"Persona-Based Policies","text":"<ul> <li>Persona is a natural concept for users, no access control lists, no pplication roles</li> <li>The assignment of personas is in the hands of users themselves with delegated governance processes, no need for super-admin</li> <li>Natural support for ABAC (Attribute-Based Access Control)</li> <li>Attribute validation based on declarations on type</li> <li>Attribute defaults based on declarations of sensible defaults</li> <li>User-defined constraints at persona level</li> <li>Time-bound and revocable persona assignments</li> </ul>"},{"location":"#persona-based-delegation","title":"Persona-Based Delegation","text":"<ul> <li>Declarative specification of delegation patterns, no coding</li> <li>Explicit delegation graph management</li> <li>Transitive delegation chain resolution</li> <li>Workflow-scoped and global delegations</li> <li>Time-bound and revocable delegations</li> </ul>"},{"location":"#defense-in-depth-security","title":"Defense-in-Depth Security","text":"<ul> <li>JWKS-based JWT validation</li> <li>4-layer input validation (Pydantic, path params, string sanitization, request size limits)</li> <li>Injection attack prevention</li> <li>Security headers on all responses</li> <li>Production-safe error handling</li> <li>Zero PII exposure to the back-end services (other than the authz-api and user-profile-api)</li> </ul>"},{"location":"#policy-governance","title":"Policy Governance","text":"<p>FlowPilot demonstrates a GitOps-based policy governance model where:</p> <ol> <li>Policies are code - OPA Rego policies live in version control</li> <li>Changes are auditable - Every policy change has a git commit hash</li> <li>Deployments are validated - Automated tests prevent broken policies from reaching production</li> <li>Rollbacks are instant - Zero-downtime rollback to previous policy versions</li> <li>History is preserved - Complete audit trail of all policy deployments</li> </ol>"},{"location":"#next-steps","title":"Next Steps","text":"<p>For Policy Governance, Auditors, Security/Privacy Officers: Start with the Policy Guide to understand how to develop and review policies with FlowPilot.</p> <p>For Architects, Auditors, Back-end Developers: Start with the Personas Guide to add FlowPilot to your application.</p> <p>For App Developers: Start with the Integration Guide to add FlowPilot to your application.</p> <p>For Platform Operators: See the Self-Hosting Guide if you want to run your own instance.</p> <p>To Understand the Model: Read the Architecture Overview and Personas Guide.</p>"},{"location":"Warp-Cursor-VSCode-Operating-Manual/","title":"Operating Manual","text":""},{"location":"Warp-Cursor-VSCode-Operating-Manual/#warp-cursor-vs-code-for-python-heavy-development","title":"Warp + Cursor + VS Code for Python-Heavy Development","text":"<p>Objective Maintain high-quality AI assistance over long sessions by strictly controlling context scope, verbosity, and responsibility boundaries.</p>"},{"location":"Warp-Cursor-VSCode-Operating-Manual/#1-tool-responsibilities-non-negotiable","title":"1. Tool Responsibilities (Non-Negotiable)","text":""},{"location":"Warp-Cursor-VSCode-Operating-Manual/#warp-execution-surface","title":"Warp \u2014 Execution Surface","text":"<p>Purpose: - Command execution - Environment interaction - Running tests, linters, builds</p> <p>Allowed: - <code>uv</code>, <code>pip</code>, <code>pytest</code>, <code>ruff</code>, <code>mypy</code>, <code>make</code> - Short outputs only</p> <p>Prohibited: - AI reasoning loops - Pasting large logs or files - Long-lived debugging sessions</p> <p>Rule: - Warp tabs are disposable.</p>"},{"location":"Warp-Cursor-VSCode-Operating-Manual/#cursor-local-ai-reasoning","title":"Cursor \u2014 Local AI Reasoning","text":"<p>Purpose: - File- or selection-scoped code changes - Refactors, explanations, test generation</p> <p>Allowed: - Explicit code selections - Single, concrete instructions - One task per prompt</p> <p>Prohibited: - \u201cUnderstand the whole project\u201d - Multi-step reasoning chains - Long chat histories</p> <p>Rule: - Always select code before invoking AI.</p>"},{"location":"Warp-Cursor-VSCode-Operating-Manual/#vs-code-system-of-record","title":"VS Code \u2014 System of Record","text":"<p>Purpose: - Navigation and comprehension - Git diffs and reviews - Final authority on correctness</p> <p>Allowed: - Manual reasoning - Search, blame, diff - Review before commit</p> <p>Rule: - AI output is untrusted until reviewed here.</p>"},{"location":"Warp-Cursor-VSCode-Operating-Manual/#2-warp-tab-discipline","title":"2. Warp Tab Discipline","text":""},{"location":"Warp-Cursor-VSCode-Operating-Manual/#one-task-one-tab","title":"One Task = One Tab","text":"<p>Examples: - Run tests - Package CLI - Build Docker image</p> <p>When task completes: - Close the tab - Open a new one</p>"},{"location":"Warp-Cursor-VSCode-Operating-Manual/#mandatory-tab-reset-triggers","title":"Mandatory Tab Reset Triggers","text":"<p>Open a new Warp tab immediately if: - Context &lt; 25% - Verbose output was produced - Logs exceed one screen - You switch problem domains</p>"},{"location":"Warp-Cursor-VSCode-Operating-Manual/#output-hygiene","title":"Output Hygiene","text":"<p>Never debug from raw terminal output.</p> <p>Instead: <pre><code>pytest tests/test_auth.py &gt; failure.txt\n</code></pre></p> <p>Review in VS Code. Extract only the relevant excerpt for AI.</p>"},{"location":"Warp-Cursor-VSCode-Operating-Manual/#3-cursor-prompting-rules","title":"3. Cursor Prompting Rules","text":""},{"location":"Warp-Cursor-VSCode-Operating-Manual/#selection-first-rule","title":"Selection-First Rule","text":"<p>Every AI prompt must have: - An explicit selection - A single, bounded objective</p> <p>Example:</p> <p>\u201cRefactor this function to remove duplication and comply with these rules: no nested functions, explicit variable names.\u201d</p>"},{"location":"Warp-Cursor-VSCode-Operating-Manual/#one-shot-principle","title":"One-Shot Principle","text":"<p>Preferred: - One prompt - Apply changes - Manual review</p> <p>If iteration is required: - Close the chat - Re-select updated code - Start a new prompt</p>"},{"location":"Warp-Cursor-VSCode-Operating-Manual/#constraint-restatement","title":"Constraint Restatement","text":"<p>Never rely on memory.</p> <p>Always restate: - Naming rules - CLI structure - Error-handling standards</p> <p>Tokens are cheaper than rework.</p>"},{"location":"Warp-Cursor-VSCode-Operating-Manual/#4-ai-exclusion-zones","title":"4. AI Exclusion Zones","text":"<p>Do not use AI for: - Cross-project reasoning - Root-cause analysis from logs alone - Reviewing its own changes - Implicit architectural decisions</p> <p>AI assists. You decide.</p>"},{"location":"Warp-Cursor-VSCode-Operating-Manual/#5-standard-work-loop","title":"5. Standard Work Loop","text":"<p>Repeat this loop continuously:</p> <ol> <li>Think (VS Code)</li> <li>Edit (Cursor)</li> <li>Run (Warp)</li> <li>Review (VS Code)</li> <li>Reset</li> </ol>"},{"location":"Warp-Cursor-VSCode-Operating-Manual/#6-quality-signals","title":"6. Quality Signals","text":"<p>You are operating correctly if: - Warp context rarely drops below 50% - Cursor changes converge in 1\u20132 passes - Diffs are small and readable - AI explanations are unnecessary - You trust reviews, not chat history</p>"},{"location":"Warp-Cursor-VSCode-Operating-Manual/#7-institutional-memory-optional","title":"7. Institutional Memory (Optional)","text":"<p>Encode standards in artifacts: - <code>README.md</code> - <code>CONTRIBUTING.md</code></p> <p>Reference them explicitly in prompts to externalize context.</p> <p>Final Rule If AI quality degrades, reset first. Never argue with a saturated context window.</p>"},{"location":"api/ai-agent/","title":"AI Agent API","text":"<p>The AI Agent API executes workflows on behalf of users with per-item authorization.</p>"},{"location":"api/ai-agent/#overview","title":"Overview","text":"<p>Base URL (Local): <code>http://localhost:8004</code> Base URL (GCP): <code>https://flowpilot-ai-agent-api-737191827545.us-central1.run.app</code></p>"},{"location":"api/ai-agent/#openapi-specification","title":"OpenAPI Specification","text":""},{"location":"api/authz/","title":"AuthZ API","text":"<p>The AuthZ API serves as the authorization fa\u00e7ade for FlowPilot, implementing the Policy Decision Point (PDP) pattern with AuthZEN-compliant request structure.</p>"},{"location":"api/authz/#overview","title":"Overview","text":"<p>Base URL (Local): <code>http://localhost:8002</code> Base URL (GCP): <code>https://flowpilot-authz-api-737191827545.us-central1.run.app</code></p>"},{"location":"api/authz/#responsibilities","title":"Responsibilities","text":"<ul> <li>Policy evaluation using OPA Rego policies (PDP)</li> <li>Authorization graph validation via delegation-api</li> <li>JWT validation and claim extraction</li> <li>Structured authorization decisions with reason codes</li> </ul>"},{"location":"api/authz/#key-features","title":"Key Features","text":"<ul> <li>AuthZEN-compliant request/response structure</li> <li>Stateless operation (no in-memory storage)</li> <li>Bearer token authentication on all endpoints (except <code>/health</code>)</li> <li>Integration with OPA for ABAC decisions</li> <li>Integration with delegation-api for ReBAC checks</li> </ul>"},{"location":"api/authz/#authentication","title":"Authentication","text":"<p>The AuthZ API accepts different token types depending on the endpoint:</p>"},{"location":"api/authz/#token-types","title":"Token Types","text":"<ul> <li>Firebase ID tokens: Only for <code>/v1/token/exchange</code> endpoint</li> <li>FlowPilot access tokens: For <code>/v1/evaluate</code> and other authorization endpoints</li> <li>GCP service tokens: For service-to-service calls (automatic)</li> </ul> User RequestsToken ExchangeService-to-Service <pre><code># First exchange Firebase ID token for FlowPilot access token\nAuthorization: Bearer &lt;flowpilot-access-token&gt;\n</code></pre> <pre><code># Only /v1/token/exchange accepts Firebase ID tokens\nAuthorization: Bearer &lt;firebase-id-token&gt;\n</code></pre> <pre><code># Services use GCP identity tokens (automatic)\nAuthorization: Bearer &lt;gcp-identity-token&gt;\n</code></pre>"},{"location":"api/authz/#endpoints","title":"Endpoints","text":""},{"location":"api/authz/#health-check","title":"Health Check","text":"<p><code>GET /health</code> - No authentication required</p> <p>Returns service health status.</p>"},{"location":"api/authz/#token-exchange","title":"Token Exchange","text":"<p><code>POST /v1/token/exchange</code> - Requires Firebase ID token</p> <p>Exchanges a Firebase ID token (containing PII) for a pseudonymous FlowPilot access token (containing only <code>sub</code>).</p> <p>Purpose: Privacy separation - keeps PII in the client, sends only UUID to backend services.</p> <p>Request Headers: <pre><code>Authorization: Bearer &lt;firebase-id-token&gt;\n</code></pre></p> <p>Response: <pre><code>{\n  \"access_token\": \"eyJhbGciOiJSUzI1NiIsImtpZCI6ImZsb3dwaWxvdC12MSJ9...\",\n  \"token_type\": \"Bearer\",\n  \"expires_in\": 900\n}\n</code></pre></p> <p>Access Token Contents: <pre><code>{\n  \"sub\": \"user-uuid\",\n  \"iss\": \"https://flowpilot-authz-api\",\n  \"aud\": \"flowpilot\",\n  \"exp\": 1768401064,\n  \"iat\": 1768400164,\n  \"token_type\": \"access\"\n}\n</code></pre></p> <p>Key Properties: - Access tokens contain only the user's UUID (<code>sub</code>), no PII - Short-lived (15 minutes by default) - Signed with FlowPilot's private RSA key - Use this token for all subsequent API calls to FlowPilot services</p>"},{"location":"api/authz/#evaluate-authorization","title":"Evaluate Authorization","text":"<p><code>POST /v1/evaluate</code> - Requires authentication</p> <p>Evaluates whether a subject (agent or user) may perform an action on a resource.</p> <p>Request Structure: <pre><code>{\n  \"subject\": {\n    \"type\": \"agent\",\n    \"id\": \"agent_flowpilot_1\"\n  },\n  \"action\": {\n    \"name\": \"execute\"\n  },\n  \"resource\": {\n    \"type\": \"workflow_item\",\n    \"id\": \"i_f032d0a2\",\n    \"properties\": {\n      \"workflow_id\": \"t_4a6455a3\"\n    }\n  },\n  \"context\": {\n    \"principal\": {\n      \"id\": \"1460e175-74f9-43af-aac3-7b4fc0547f05\"\n    }\n  },\n  \"options\": {\n    \"dry_run\": true,\n    \"explain\": true\n  }\n}\n</code></pre></p> <p>Response Structure: <pre><code>{\n  \"decision\": \"allow\",\n  \"reason_codes\": [],\n  \"advice\": []\n}\n</code></pre></p>"},{"location":"api/authz/#decision-flow","title":"Decision Flow","text":"<ol> <li>JWT Validation: Validate bearer token and extract claims</li> <li>Delegation Check: If subject \u2260 principal, query delegation-api (ReBAC)</li> <li>Policy Evaluation: Build OPA input and query OPA (ABAC)</li> <li>Return Decision: Structured response with decision, reason codes, and advice</li> </ol>"},{"location":"api/authz/#openapi-specification","title":"OpenAPI Specification","text":""},{"location":"api/authz/#error-handling","title":"Error Handling","text":"Status Code Description 200 Authorization decision returned 400 Bad request or downstream failure 401 Unauthorized (invalid token) 403 Forbidden 422 Validation error 500 Internal server error"},{"location":"api/authz/#example-usage","title":"Example Usage","text":""},{"location":"api/authz/#curl-example","title":"cURL Example","text":"With Token Exchange (Recommended)Service-to-Service (Keycloak) <pre><code># Step 1: Authenticate with Firebase and get ID token\nFIREBASE_TOKEN=$(curl -s -X POST \\\n  \"https://identitytoolkit.googleapis.com/v1/accounts:signInWithPassword?key=$FIREBASE_API_KEY\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"email\":\"user@example.com\",\"password\":\"password\",\"returnSecureToken\":true}' \\\n  | jq -r '.idToken')\n\n# Step 2: Exchange for FlowPilot access token (pseudonymous)\nACCESS_TOKEN=$(curl -s -X POST http://localhost:8002/v1/token/exchange \\\n  -H \"Authorization: Bearer $FIREBASE_TOKEN\" \\\n  | jq -r '.access_token')\n\n# Step 3: Make authorization request with access token\ncurl -X POST http://localhost:8002/v1/evaluate \\\n  -H \"Authorization: Bearer $ACCESS_TOKEN\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"subject\": {\"type\": \"agent\", \"id\": \"agent-runner\"},\n    \"action\": {\"name\": \"execute\"},\n    \"resource\": {\n      \"type\": \"workflow_item\",\n      \"id\": \"i_abc123\",\n      \"properties\": {\"workflow_id\": \"w_xyz789\"}\n    },\n    \"context\": {\n      \"principal\": {\"id\": \"user-uuid\"}\n    }\n  }'\n</code></pre> <pre><code># Get service token\nTOKEN=$(curl -s -X POST \\\n  \"http://localhost:8080/realms/flowpilot/protocol/openid-connect/token\" \\\n  -d \"grant_type=client_credentials\" \\\n  -d \"client_id=flowpilot-agent\" \\\n  -d \"client_secret=$AGENT_CLIENT_SECRET\" | jq -r '.access_token')\n\n# Make authorization request\ncurl -X POST http://localhost:8002/v1/evaluate \\\n  -H \"Authorization: Bearer $TOKEN\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"subject\": {\"type\": \"agent\", \"id\": \"agent-runner\"},\n    \"action\": {\"name\": \"execute\"},\n    \"resource\": {\n      \"type\": \"workflow_item\",\n      \"id\": \"i_abc123\",\n      \"properties\": {\"workflow_id\": \"w_xyz789\"}\n    },\n    \"context\": {\n      \"principal\": {\"id\": \"user-uuid\"}\n    }\n  }'\n</code></pre>"},{"location":"api/authz/#python-example","title":"Python Example","text":"<pre><code>import requests\n\n# Step 1: Authenticate with Firebase\nfirebase_response = requests.post(\n    \"https://identitytoolkit.googleapis.com/v1/accounts:signInWithPassword\",\n    params={\"key\": FIREBASE_API_KEY},\n    json={\n        \"email\": \"user@example.com\",\n        \"password\": \"password\",\n        \"returnSecureToken\": True\n    }\n)\nfirebase_token = firebase_response.json()[\"idToken\"]\n\n# Step 2: Exchange for FlowPilot access token\nexchange_response = requests.post(\n    \"http://localhost:8002/v1/token/exchange\",\n    headers={\"Authorization\": f\"Bearer {firebase_token}\"}\n)\naccess_token = exchange_response.json()[\"access_token\"]\n\n# Step 3: Make authorization request with access token\nheaders = {\n    \"Authorization\": f\"Bearer {access_token}\",\n    \"Content-Type\": \"application/json\"\n}\n\nauthz_request = {\n    \"subject\": {\"type\": \"agent\", \"id\": \"agent-runner\"},\n    \"action\": {\"name\": \"execute\"},\n    \"resource\": {\n        \"type\": \"workflow_item\",\n        \"id\": \"i_abc123\",\n        \"properties\": {\"workflow_id\": \"w_xyz789\"}\n    },\n    \"context\": {\n        \"principal\": {\"id\": \"user-uuid\"}\n    }\n}\n\nresponse = requests.post(\n    \"http://localhost:8002/v1/evaluate\",\n    json=authz_request,\n    headers=headers\n)\n\ndecision = response.json()\nprint(f\"Decision: {decision['decision']}\")\n</code></pre>"},{"location":"api/authz/#related-documentation","title":"Related Documentation","text":"<ul> <li>Authorization Architecture</li> <li>OPA Policy Development</li> <li>Delegation API</li> </ul>"},{"location":"api/delegation/","title":"Delegation API","text":"<p>The Delegation API manages delegation relationships (ReBAC) for FlowPilot.</p>"},{"location":"api/delegation/#overview","title":"Overview","text":"<p>Base URL (Local): <code>http://localhost:8005</code> Base URL (GCP): <code>https://flowpilot-delegation-api-737191827545.us-central1.run.app</code></p>"},{"location":"api/delegation/#openapi-specification","title":"OpenAPI Specification","text":""},{"location":"api/domain-services/","title":"Domain Services API","text":"<p>The Domain Services API is the workflow system-of-record, managing trips (workflows) and booking items (workflow items).</p>"},{"location":"api/domain-services/#overview","title":"Overview","text":"<p>Base URL (Local): <code>http://localhost:8003</code> Base URL (GCP): <code>https://flowpilot-domain-services-api-737191827545.us-central1.run.app</code></p>"},{"location":"api/domain-services/#openapi-specification","title":"OpenAPI Specification","text":""},{"location":"api/persona/","title":"Persona API","text":"<p>The Persona API provides persona lifecycle management for FlowPilot's authorization system.</p>"},{"location":"api/persona/#overview","title":"Overview","text":"<p>Base URL (Local): <code>http://localhost:8006</code> Base URL (GCP): <code>https://flowpilot-persona-api-737191827545.us-central1.run.app</code></p>"},{"location":"api/persona/#responsibilities","title":"Responsibilities","text":"<ul> <li>Persona lifecycle management (CRUD operations)</li> <li>Autobook preference management per persona</li> <li>Service-to-service persona lookup for authorization decisions</li> </ul>"},{"location":"api/persona/#key-features","title":"Key Features","text":"<ul> <li>Multi-persona support - Users can have multiple independent personas</li> <li>Unique persona titles - Each user can only have one persona per title (enforced)</li> <li>Persona-scoped autobook settings - Each persona has its own consent and thresholds</li> <li>Temporal validity - Personas have status and valid time ranges</li> <li>JWT authentication - All endpoints require authentication (except <code>/health</code>)</li> <li>Service account support - AuthZ-API can fetch any user's personas</li> <li>Storage backends - SQLite (local) or Firestore (GCP)</li> <li>Zero PII proliferation - Only UUID and persona processed</li> </ul>"},{"location":"api/persona/#authentication","title":"Authentication","text":"<p>All endpoints (except <code>/health</code>) require a Bearer token:</p> Local (Keycloak)GCP (Firebase) <pre><code>Authorization: Bearer &lt;keycloak-jwt-token&gt;\n</code></pre> <pre><code>Authorization: Bearer &lt;firebase-id-token&gt;\n</code></pre>"},{"location":"api/persona/#endpoints","title":"Endpoints","text":""},{"location":"api/persona/#health-check","title":"Health Check","text":"<p><code>GET /health</code> - No authentication required</p>"},{"location":"api/persona/#compatibility-endpoints","title":"Compatibility Endpoints","text":"<p>These endpoints provide a simplified interface for applications migrating from legacy profile management. They wrap the persona system internally while maintaining backward-compatible response formats.</p>"},{"location":"api/persona/#get-simplified-profile","title":"Get Simplified Profile","text":"<p><code>GET /v1/profile/simple</code> - Get authenticated user's profile in simplified format</p> <p>Description: Returns the first active persona's attributes in a simplified profile format. If the user has no active personas, returns default values.</p> <p>Response (200 OK): <pre><code>{\n  \"sub\": \"PKbHpCqDnLcNywEo8pev8yQmoU43\",\n  \"personas\": [\"traveler\"],\n  \"consent\": true,\n  \"autobook_price\": 5000,\n  \"autobook_leadtime\": 7,\n  \"autobook_risklevel\": 3\n}\n</code></pre></p> <p>Note: Uses the most recently created active persona for autobook preferences.</p>"},{"location":"api/persona/#list-users-by-persona-title","title":"List Users by Persona Title","text":"<p><code>GET /v1/users/by-persona?title={title}</code> - List users with a specific persona title</p> <p>Query Parameters: - <code>title</code> (required): Persona title to filter by (e.g., \"travel-agent\", \"traveler\")</p> <p>Response (200 OK): <pre><code>{\n  \"users\": [\n    {\n      \"sub\": \"bcadc299-f463-4f7d-bab5-2221761387f4\",\n      \"email\": null,\n      \"persona\": \"travel-agent\"\n    },\n    {\n      \"sub\": \"ef456789-abcd-1234-5678-9abcdef01234\",\n      \"email\": null,\n      \"persona\": \"travel-agent\"\n    }\n  ]\n}\n</code></pre></p> <p>Note: Email field is always <code>null</code> as email addresses are not stored in the persona system.</p> <p>Use Case: Finding delegation candidates (e.g., all travel agents)</p>"},{"location":"api/persona/#persona-management-endpoints","title":"Persona Management Endpoints","text":"<p>These endpoints provide full lifecycle management of user personas with rich metadata and temporal validity.</p>"},{"location":"api/persona/#create-persona","title":"Create Persona","text":"<p><code>POST /v1/personas</code> - Create a new persona for the authenticated user</p> <p>Request Body: <pre><code>{\n  \"title\": \"traveler\",\n  \"scope\": [\"read\", \"execute\"],\n  \"valid_from\": \"2024-01-01T00:00:00Z\",\n  \"valid_till\": \"2026-12-31T23:59:59Z\",\n  \"status\": \"active\",\n  \"consent\": true,\n  \"autobook_price\": 5000,\n  \"autobook_leadtime\": 7,\n  \"autobook_risklevel\": 3\n}\n</code></pre></p> <p>Note: Each user can only have one persona per title. Attempting to create a duplicate persona title will result in a 400 error.</p> <p>Response (201 Created): <pre><code>{\n  \"persona_id\": \"b9678f30-f4b0-4033-82db-846357311165\",\n  \"user_sub\": \"PKbHpCqDnLcNywEo8pev8yQmoU43\",\n  \"title\": \"traveler\",\n  \"status\": \"active\",\n  \"scope\": [\"read\", \"execute\"],\n  \"valid_from\": \"2024-01-01T00:00:00Z\",\n  \"valid_till\": \"2026-12-31T23:59:59Z\",\n  \"created_at\": \"2026-01-13T17:00:00Z\",\n  \"updated_at\": \"2026-01-13T17:00:00Z\",\n  \"consent\": true,\n  \"autobook_price\": 5000,\n  \"autobook_leadtime\": 7,\n  \"autobook_risklevel\": 3\n}\n</code></pre></p>"},{"location":"api/persona/#list-personas","title":"List Personas","text":"<p><code>GET /v1/personas?status={status}</code> - List authenticated user's personas</p> <p>Query Parameters: - <code>status</code> (optional): Filter by status (\"active\", \"inactive\", \"suspended\", \"expired\")</p> <p>Response: <pre><code>{\n  \"personas\": [\n    {\n      \"persona_id\": \"b9678f30-f4b0-4033-82db-846357311165\",\n      \"user_sub\": \"PKbHpCqDnLcNywEo8pev8yQmoU43\",\n      \"title\": \"traveler\",\n      \"status\": \"active\",\n      \"scope\": [\"read\", \"execute\"],\n      \"valid_from\": \"2024-01-01T00:00:00Z\",\n      \"valid_till\": \"2026-12-31T23:59:59Z\",\n      \"created_at\": \"2026-01-13T17:00:00Z\",\n      \"updated_at\": \"2026-01-13T17:00:00Z\",\n      \"consent\": true,\n      \"autobook_price\": 5000,\n      \"autobook_leadtime\": 7,\n      \"autobook_risklevel\": 3\n    }\n  ]\n}\n</code></pre></p>"},{"location":"api/persona/#get-persona","title":"Get Persona","text":"<p><code>GET /v1/personas/{persona_id}</code> - Get a specific persona</p> <p>Response: Single persona object (same format as create response)</p> <p>Authorization: Persona must belong to authenticated user</p>"},{"location":"api/persona/#update-persona","title":"Update Persona","text":"<p><code>PUT /v1/personas/{persona_id}</code> - Update persona (partial update)</p> <p>Request Body: All fields optional <pre><code>{\n  \"autobook_price\": 8000,\n  \"autobook_leadtime\": 14,\n  \"status\": \"active\"\n}\n</code></pre></p> <p>Response: Updated persona object</p> <p>Authorization: Persona must belong to authenticated user</p>"},{"location":"api/persona/#delete-persona","title":"Delete Persona","text":"<p><code>DELETE /v1/personas/{persona_id}</code> - Delete a persona</p> <p>Response: 204 No Content</p> <p>Authorization: Persona must belong to authenticated user</p>"},{"location":"api/persona/#list-users-personas-service-accounts-only","title":"List User's Personas (Service Accounts Only)","text":"<p><code>GET /v1/users/{user_sub}/personas?status={status}</code> - List personas for any user</p> <p>Authorization: Requires service account token - Keycloak: <code>client_id=flowpilot-agent</code> - GCP: Email contains <code>gserviceaccount.com</code></p> <p>Response: Same format as <code>GET /v1/personas</code></p> <p>Use Case: AuthZ-API uses this endpoint to fetch persona data for authorization decisions</p>"},{"location":"api/persona/#openapi-specification","title":"OpenAPI Specification","text":""},{"location":"api/persona/#example-usage","title":"Example Usage","text":""},{"location":"api/persona/#list-users-by-persona-title_1","title":"List Users by Persona Title","text":"<pre><code>curl -X GET \"http://localhost:8006/v1/users/by-persona?title=travel-agent\" \\\n  -H \"Authorization: Bearer $TOKEN\"\n</code></pre> <p>Response: <pre><code>{\n  \"users\": [\n    {\n      \"sub\": \"bcadc299-f463-4f7d-bab5-2221761387f4\",\n      \"email\": null,\n      \"persona\": \"travel-agent\"\n    }\n  ]\n}\n</code></pre></p>"},{"location":"api/persona/#create-a-persona","title":"Create a Persona","text":"<pre><code>TOKEN=\"your-firebase-or-keycloak-token\"\n\ncurl -X POST http://localhost:8006/v1/personas \\\n  -H \"Authorization: Bearer $TOKEN\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"title\": \"traveler\",\n    \"scope\": [\"read\", \"execute\"],\n    \"valid_from\": \"2024-01-01T00:00:00Z\",\n    \"valid_till\": \"2026-12-31T23:59:59Z\",\n    \"status\": \"active\",\n    \"consent\": true,\n    \"autobook_price\": 5000,\n    \"autobook_leadtime\": 7,\n    \"autobook_risklevel\": 3\n  }'\n</code></pre>"},{"location":"api/persona/#list-your-personas","title":"List Your Personas","text":"<pre><code>curl -X GET http://localhost:8006/v1/personas \\\n  -H \"Authorization: Bearer $TOKEN\"\n</code></pre>"},{"location":"api/persona/#list-active-personas-only","title":"List Active Personas Only","text":"<pre><code>curl -X GET \"http://localhost:8006/v1/personas?status=active\" \\\n  -H \"Authorization: Bearer $TOKEN\"\n</code></pre>"},{"location":"api/persona/#get-specific-persona","title":"Get Specific Persona","text":"<pre><code>PERSONA_ID=\"b9678f30-f4b0-4033-82db-846357311165\"\n\ncurl -X GET http://localhost:8006/v1/personas/$PERSONA_ID \\\n  -H \"Authorization: Bearer $TOKEN\"\n</code></pre>"},{"location":"api/persona/#update-autobook-preferences","title":"Update Autobook Preferences","text":"<pre><code>curl -X PUT http://localhost:8006/v1/personas/$PERSONA_ID \\\n  -H \"Authorization: Bearer $TOKEN\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"autobook_price\": 8000,\n    \"autobook_leadtime\": 14\n  }'\n</code></pre>"},{"location":"api/persona/#deactivate-a-persona","title":"Deactivate a Persona","text":"<pre><code>curl -X PUT http://localhost:8006/v1/personas/$PERSONA_ID \\\n  -H \"Authorization: Bearer $TOKEN\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"status\": \"inactive\"\n  }'\n</code></pre>"},{"location":"api/persona/#delete-a-persona","title":"Delete a Persona","text":"<pre><code>curl -X DELETE http://localhost:8006/v1/personas/$PERSONA_ID \\\n  -H \"Authorization: Bearer $TOKEN\"\n</code></pre>"},{"location":"api/persona/#error-handling","title":"Error Handling","text":"Status Code Description 200 Success (GET, PUT) 201 Created (POST) 204 No Content (DELETE) 400 Validation error (invalid title, out of range values) 401 Unauthorized (invalid or missing token) 403 Forbidden (not owner of persona, or service account required) 404 Persona not found 500 Internal server error"},{"location":"api/persona/#common-error-examples","title":"Common Error Examples","text":"<p>400 Bad Request - Invalid Title: <pre><code>{\n  \"detail\": \"Invalid persona title 'invalid-persona'. Allowed: admin, booking-assistant, office-manager, travel-agent, traveler\"\n}\n</code></pre></p> <p>400 Bad Request - Duplicate Title: <pre><code>{\n  \"detail\": \"Persona with title 'traveler' already exists for this user. Each user can only have one persona per title.\"\n}\n</code></pre></p> <p>400 Bad Request - Max Personas: <pre><code>{\n  \"detail\": \"Maximum 5 personas per user. Delete an existing persona first.\"\n}\n</code></pre></p> <p>403 Forbidden (User endpoint): <pre><code>{\n  \"detail\": \"Persona does not belong to authenticated user\"\n}\n</code></pre></p> <p>403 Forbidden (Service endpoint): <pre><code>{\n  \"detail\": \"Forbidden: Service account required\"\n}\n</code></pre></p> <p>404 Not Found: <pre><code>{\n  \"detail\": \"Persona not found\"\n}\n</code></pre></p>"},{"location":"api/persona/#storage-backends","title":"Storage Backends","text":""},{"location":"api/persona/#local-development-sqlite","title":"Local Development (SQLite)","text":"<ul> <li>In-memory or file-based SQLite database</li> <li>Zero configuration</li> <li>Perfect for local testing</li> </ul>"},{"location":"api/persona/#production-firestore","title":"Production (Firestore)","text":"<ul> <li>Google Cloud Firestore (NoSQL)</li> <li>Serverless, auto-scaling</li> <li>Requires composite indexes (defined in <code>infra/firebase/firestore.indexes.json</code>)</li> </ul> <p>Deploy indexes: <pre><code># Using gcloud CLI:\ngcloud firestore indexes composite create \\\n  --collection-group=personas \\\n  --query-scope=COLLECTION \\\n  --field-config field-path=user_sub,order=ascending \\\n  --field-config field-path=status,order=ascending \\\n  --field-config field-path=created_at,order=descending\n\ngcloud firestore indexes composite create \\\n  --collection-group=personas \\\n  --query-scope=COLLECTION \\\n  --field-config field-path=user_sub,order=ascending \\\n  --field-config field-path=created_at,order=descending\n\n# Or using Firebase CLI:\nfirebase deploy --only firestore:indexes\n</code></pre></p>"},{"location":"api/persona/#related-documentation","title":"Related Documentation","text":"<ul> <li>Persona Guide - Complete persona management guide</li> <li>Policy Development Guide - How OPA uses persona data</li> <li>Authorization Architecture - Overall authorization flow</li> <li>Delegation API - Manage delegation relationships</li> </ul>"},{"location":"architecture/authentication/","title":"Authentication Architecture","text":"<p>FlowPilot implements a two-tier token architecture designed to maximize privacy and minimize PII exposure across the platform. Client applications authenticate with Firebase (or Keycloak for local development), then immediately exchange the OIDC ID token for a pseudonymous FlowPilot access token that contains only the user's subject identifier (<code>sub</code>).</p>"},{"location":"architecture/authentication/#core-principles","title":"Core Principles","text":""},{"location":"architecture/authentication/#privacy-by-design","title":"Privacy by Design","text":"<p>FlowPilot tokens contain ZERO PII: - \u274c No name, no username - \u274c No email addresses  - \u274c No persona attributes - \u2705 Only the pseudononymous UUID (<code>sub</code>)</p> <p>Benefits: - Tokens remain small and stable - Privacy preserved by design - Lower breach impact (token compromise reveals no PII) - GDPR-friendly - Minimal data exposure to services and logs</p>"},{"location":"architecture/authentication/#separation-of-concerns","title":"Separation of Concerns","text":"<p>Identity Provider (Firebase/Keycloak): - Manages user accounts and credentials - Issues OIDC ID tokens for authentication - Supports a wide variety of authentication mechanisms, including federation and two-factor - Client-facing only - backend services never see these tokens</p> <p>FlowPilot AuthZ API: - Exchanges OIDC tokens for pseudonymous access tokens - Issues minimal JWTs with <code>sub</code> only - Signs tokens with FlowPilot's private key - All backend services validate FlowPilot tokens</p> <p>Authorization Services: - Operate on pseudonymous tokens (<code>sub</code> only) - Fetch persona attributes on-demand when needed for policy decisions - Only authz-api, persona-api, and OPA see persona details</p> <p>Domain-specifc Services: - Operate on pseudonymous tokens (<code>sub</code> only) - Never obtain user account data for the identity provider or through a JWT - Never obtain any persona attributes</p>"},{"location":"architecture/authentication/#privacy-architecture","title":"Privacy Architecture","text":""},{"location":"architecture/authentication/#data-flow-separation","title":"Data Flow Separation","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                      CLIENT TIER                             \u2502\n\u2502  \u2022 Firebase ID Token (contains PII: email, name, etc.)       \u2502\n\u2502  \u2022 Used ONLY for initial authentication                      \u2502\n\u2502  \u2022 NEVER sent to backend services                            \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                            \u2193\n                    Token Exchange\n                            \u2193\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                   BACKEND SERVICE TIER                       \u2502\n\u2502  \u2022 FlowPilot Access Token (contains ONLY sub UUID)           \u2502\n\u2502  \u2022 Used for ALL backend API calls                            \u2502\n\u2502  \u2022 No PII in tokens or logs                                  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                            \u2193\n                  Authorization Decision Needed\n                            \u2193\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                  AUTHORIZATION TIER                          \u2502\n\u2502  \u2022 AuthZ API fetches persona attributes on-demand            \u2502\n\u2502  \u2022 Only authz-api, persona-api, and OPA see attributes  \u2502\n\u2502  \u2022 Attributes never logged or exposed                        \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"architecture/authentication/#services-and-pii-exposure","title":"Services and PII Exposure","text":"Service Sees User UUID Sees PII Sees Persona Attributes Client Apps \u2705 \u2705 (Firebase token) \u274c AuthZ API (exchange endpoint) \u2705 \u2705 (during exchange only) \u274c AuthZ API (evaluate endpoint) \u2705 \u274c \u2705 (owner only, for policies) User Profile API \u2705 \u274c \u2705 (owns persona data) Domain Services API \u2705 \u274c \u274c Delegation API \u2705 \u274c \u274c AI Agent API \u2705 \u274c \u274c OPA \u2705 \u274c \u2705 (for policy evaluation) <p>Key Insight: Most services operate with zero knowledge of user identity beyond UUID. Only 3 services (authz-api, persona-api, OPA) ever see persona attributes, and only when making authorization decisions.</p>"},{"location":"architecture/authentication/#security-considerations","title":"Security Considerations","text":""},{"location":"architecture/authentication/#token-storage","title":"Token Storage","text":"<p>Client Applications: - Store FlowPilot access tokens securely (iOS Keychain, secure storage) - Never log tokens - Clear tokens on logout - Refresh proactively before expiry</p> <p>Backend Services: - Tokens are transient (not stored) - Validate on every request - Never log tokens</p>"},{"location":"architecture/authentication/#token-transmission","title":"Token Transmission","text":"<ul> <li>Always use HTTPS in production</li> <li>Use Authorization header (never query parameters)</li> <li>Never expose tokens in logs, error messages, or URLs</li> </ul>"},{"location":"architecture/authentication/#defense-in-depth","title":"Defense in Depth","text":"<p>Layer 1: Signature Validation - All tokens cryptographically verified</p> <p>Layer 2: Issuer/Audience Validation - Prevents token substitution attacks</p> <p>Layer 3: Expiry Checks - Short-lived tokens (15 minutes)</p> <p>Layer 4: Token Type Validation - Ensures correct token for endpoint</p> <p>Layer 5: Minimal Claims - Only <code>sub</code> exposed (no PII)</p>"},{"location":"architecture/authentication/#authentication-flows","title":"Authentication Flows","text":""},{"location":"architecture/authentication/#1-client-authentication-token-exchange","title":"1. Client Authentication &amp; Token Exchange","text":"<p>Flow: OIDC Authentication \u2192 Token Exchange \u2192 Platform Access</p> <p>Client applications (web app, iOS app, test scripts) follow this pattern:</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Client  \u2502                    \u2502 Firebase \u2502                 \u2502  AuthZ API \u2502\n\u2502   App   \u2502                    \u2502   Auth   \u2502                 \u2502            \u2502\n\u2514\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2518                    \u2514\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2518                 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2518\n     \u2502                               \u2502                             \u2502\n     \u2502 1. Sign in (email/password)   \u2502                             \u2502\n     \u2502\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500&gt;\u2502                             \u2502\n     \u2502                               \u2502                             \u2502\n     \u2502 2. Firebase id-token (PII)    \u2502                             \u2502\n     \u2502&lt;\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2502                             \u2502\n     \u2502                               \u2502                             \u2502\n     \u2502 3. POST /v1/token/exchange    \u2502                             \u2502\n     \u2502    Bearer: &lt;Firebase id-token&gt;\u2502                             \u2502\n     \u2502\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500&gt;\u2502\n     \u2502                               \u2502                             \u2502\n     \u2502                               \u2502    4. Validate Firebase token\n     \u2502                               \u2502    5. Extract sub (UUID)    \u2502\n     \u2502                               \u2502    6. Create minimal JWT    \u2502\n     \u2502                               \u2502                             \u2502\n     \u2502 7. FlowPilot access-token (sub only)                        \u2502\n     \u2502&lt;\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2502\n     \u2502                               \u2502                             \u2502\n     \u2502 8. Use access-token for ALL backend API calls               \u2502\n     \u2502    (domain-services, workflows, delegations, etc.)          \u2502\n     \u2502                               \u2502                             \u2502\n</code></pre> <p>Steps:</p> <ol> <li>User authenticates with Firebase/Keycloak (email/password, OAuth, passwordless, federated, etc.)</li> <li>Identity provider issues id-token containing PII (email, name, etc.)</li> <li>Client immediately exchanges id-token for FlowPilot access token:    <pre><code>POST https://flowpilot-authz-api/v1/token/exchange\nAuthorization: Bearer &lt;Firebase id-Token&gt;\n</code></pre></li> <li>AuthZ API validates Firebase id-token and extracts <code>sub</code> (user UUID)</li> <li>AuthZ API issues pseudonymous FlowPilot access-token:    <pre><code>{\n  \"access_token\": \"eyJ...\",\n  \"token_type\": \"Bearer\",\n  \"expires_in\": 900\n}\n</code></pre></li> <li>Client uses FlowPilot access-token for all subsequent backend API calls</li> <li>Backend services validate FlowPilot tokens using public key</li> </ol> <p>FlowPilot Access Token Contents (Pseudonymous):</p> <pre><code>{\n  \"sub\": \"89eb5366-bab3-46e4-b8e1-abc5f2ea4631\",\n  \"iss\": \"https://flowpilot-authz-api\",\n  \"aud\": \"flowpilot\",\n  \"token_type\": \"access\",\n  \"exp\": 1704901200,\n  \"iat\": 1704897600\n}\n</code></pre> <p>Key Properties: - Contains only the user's UUID (<code>sub</code>) - Signed by FlowPilot private key (RS256) - Short-lived (15 minutes default) - All backend services use this token - No PII whatsoever</p>"},{"location":"architecture/authentication/#2-service-to-service-authentication","title":"2. Service-to-Service Authentication","text":"<p>Flow: GCP Identity Tokens (Cloud Run) or Client Credentials (Local)</p> <p>Backend services authenticate to each other using service accounts.</p> <p>Production (GCP Cloud Run):</p> <pre><code>import google.auth\nimport google.auth.transport.requests\n\ndef get_service_token():\n    \"\"\"Get service-to-service access token from GCP metadata server.\"\"\"\n    credentials, project = google.auth.default()\n    auth_req = google.auth.transport.requests.Request()\n    credentials.refresh(auth_req)\n    return credentials.token\n\n# Use token in requests\nheaders = {\"Authorization\": f\"Bearer {get_service_token()}\"}\nresponse = requests.post(url, json=data, headers=headers)\n</code></pre> <p>Local Development (Keycloak):</p> <pre><code>import requests\n\ndef get_service_token_local():\n    \"\"\"Get service token using client credentials flow.\"\"\"\n    response = requests.post(\n        keycloak_token_url,\n        data={\n            \"grant_type\": \"client_credentials\",\n            \"client_id\": \"flowpilot-agent\",\n            \"client_secret\": os.environ[\"AGENT_CLIENT_SECRET\"],\n        }\n    )\n    return response.json()[\"access_token\"]\n</code></pre> <p>Service Account Personas: - <code>ai-agent</code> - AI agents executing workflows - <code>service</code> - Generic service accounts</p>"},{"location":"architecture/authentication/#token-validation","title":"Token Validation","text":""},{"location":"architecture/authentication/#flowpilot-token-validation-primary-method","title":"FlowPilot Token Validation (Primary Method)","text":"<p>All backend services validate FlowPilot access tokens using the shared security library.</p> <p>Validation Process:</p> <ol> <li>Extract token from Authorization header</li> <li>Load FlowPilot public key (cached, from file or env var)</li> <li>Verify signature using RS256 algorithm</li> <li>Validate issuer (<code>https://flowpilot-authz-api</code>)</li> <li>Validate audience (<code>flowpilot</code>)</li> <li>Check expiry (<code>exp</code> &gt; now)</li> <li>Verify token type (<code>token_type == \"access\"</code>)</li> <li>Extract sub (user UUID)</li> </ol> <p>Implementation Pattern:</p> <pre><code>from fastapi import Depends, HTTPException\nimport security\n\ndef get_token_claims(\n    token_claims: dict = Depends(security.verify_token)\n) -&gt; dict:\n    \"\"\"Dependency that validates FlowPilot JWT and returns claims.\"\"\"\n    return token_claims\n\n@app.post(\"/protected-endpoint\")\ndef protected_handler(\n    token_claims: dict = Depends(get_token_claims)\n):\n    user_sub = token_claims[\"sub\"]  # Only sub available - no PII\n\n    # Use validated UUID\n    return {\"message\": f\"Hello {user_sub}\"}\n</code></pre> <p>Configuration (Environment Variables):</p> <pre><code># FlowPilot token validation (all services)\nFLOWPILOT_PUBLIC_KEY_PATH=/secrets/signing-key-pub  # Public key for verification\nFLOWPILOT_TOKEN_ISSUER=https://flowpilot-authz-api\nFLOWPILOT_TOKEN_AUDIENCE=flowpilot\n\n# Or use environment variable directly (Cloud Run secrets)\nSIGNING_KEY_PUB_CONTENT=\"-----BEGIN PUBLIC KEY-----\\n...\"\n</code></pre>"},{"location":"architecture/authentication/#firebase-token-validation-exchange-endpoint-only","title":"Firebase Token Validation (Exchange Endpoint Only)","text":"<p>Only the <code>/v1/token/exchange</code> endpoint validates Firebase tokens using Firebase Admin SDK.</p> <pre><code>from fastapi import Depends\nimport security\n\n@app.post(\"/v1/token/exchange\")\ndef post_token_exchange(\n    token_claims: dict = Depends(security.verify_firebase_token),\n):\n    \"\"\"Exchange Firebase ID token for FlowPilot access token.\"\"\"\n    user_sub = token_claims[\"sub\"]\n\n    # Create minimal FlowPilot token with sub only\n    access_token = create_flowpilot_token(user_sub)\n\n    return {\n        \"access_token\": access_token,\n        \"token_type\": \"Bearer\",\n        \"expires_in\": 900\n    }\n</code></pre> <p>Firebase Admin SDK automatically: - Verifies signature using Firebase public keys - Validates issuer (Firebase project) - Validates audience - Checks token expiry - Caches public keys (no per-request network calls)</p>"},{"location":"architecture/authentication/#token-lifecycle","title":"Token Lifecycle","text":""},{"location":"architecture/authentication/#1-initial-authentication","title":"1. Initial Authentication","text":"<pre><code>User \u2192 Firebase \u2192 Client receives ID token (with PII)\n</code></pre>"},{"location":"architecture/authentication/#2-token-exchange","title":"2. Token Exchange","text":"<pre><code>Client \u2192 AuthZ API /v1/token/exchange \u2192 Client receives access token (sub only)\n</code></pre>"},{"location":"architecture/authentication/#3-backend-api-calls","title":"3. Backend API Calls","text":"<pre><code>Client \u2192 Backend Service \u2192 Validates FlowPilot token \u2192 Extracts sub\n</code></pre>"},{"location":"architecture/authentication/#4-persona-data-fetching-on-demand","title":"4. Persona Data Fetching (On-Demand)","text":"<p>When authorization decisions require persona attributes:</p> <pre><code>Backend Service \u2192 AuthZ API /v1/evaluate\n                    \u2193\n               AuthZ API fetches persona from persona-api\n                    \u2193\n               OPA evaluates policy with persona attributes\n                    \u2193\n               Decision returned (allow/deny + reasons)\n</code></pre> <p>Key Point: Persona attributes are never in tokens. They are fetched on-demand only when needed for authorization decisions, and only authz-api, persona-api, and OPA see them.</p>"},{"location":"architecture/authentication/#token-expiry-and-refresh","title":"Token Expiry and Refresh","text":"<p>FlowPilot Access Token: - Short-lived (15 minutes default, configurable) - Client must re-exchange Firebase token when expired</p> <p>Firebase ID Token: - Firebase SDK handles automatic refresh - Typically 1 hour lifetime</p> <p>Refresh Flow:</p> <pre><code># Client-side refresh logic\ndef get_valid_access_token():\n    if flowpilot_token_expired():\n        # Get fresh Firebase token (SDK auto-refreshes)\n        firebase_token = firebase.auth().currentUser.getIdToken()\n\n        # Exchange for new FlowPilot token\n        response = requests.post(\n            f\"{authz_api_url}/v1/token/exchange\",\n            headers={\"Authorization\": f\"Bearer {firebase_token}\"}\n        )\n        return response.json()[\"access_token\"]\n\n    return cached_flowpilot_token\n</code></pre>"},{"location":"architecture/authentication/#key-management","title":"Key Management","text":""},{"location":"architecture/authentication/#flowpilot-signing-keys","title":"FlowPilot Signing Keys","text":"<p>Private Key (AuthZ API only): - Signs FlowPilot access tokens - Stored in <code>/secrets/flowpilot-signing-key.pem</code> - RSA 2048-bit or higher - Never exposed outside authz-api</p> <p>Public Key (All Services): - Validates FlowPilot access tokens - Stored in <code>/secrets/flowpilot-signing-key-pub.pem</code> - Distributed to all backend services - Can be public (no security risk)</p> <p>Generation:</p> <pre><code># Generate RSA key pair\nopenssl genrsa -out flowpilot-signing-key.pem 2048\nopenssl rsa -in flowpilot-signing-key.pem -pubout -out flowpilot-signing-key-pub.pem\n\n# Store in secrets directory\ncp flowpilot-signing-key*.pem secrets/\n</code></pre> <p>Cloud Run Secret Mounting:</p> <pre><code># Create secrets in Google Secret Manager\ngcloud secrets create flowpilot-signing-key --data-file=secrets/flowpilot-signing-key.pem\ngcloud secrets create flowpilot-signing-key-pub --data-file=secrets/flowpilot-signing-key-pub.pem\n\n# Mount as environment variables in Cloud Run\ngcloud run services update flowpilot-authz-api \\\n  --update-secrets SIGNING_KEY_CONTENT=flowpilot-signing-key:latest\n\ngcloud run services update flowpilot-domain-services-api \\\n  --update-secrets SIGNING_KEY_PUB_CONTENT=flowpilot-signing-key-pub:latest\n</code></pre>"},{"location":"architecture/authentication/#troubleshooting","title":"Troubleshooting","text":""},{"location":"architecture/authentication/#invalid-token-signature","title":"Invalid Token Signature","text":"<p>Symptom: 401 Unauthorized - \"Invalid FlowPilot access token\"</p> <p>Causes: - Public key mismatch (services using wrong key) - Token signed with wrong private key - Clock skew between services</p> <p>Solutions:</p> <pre><code># Verify public key is correct\ncat /secrets/flowpilot-signing-key-pub.pem\n\n# Check environment configuration\necho $FLOWPILOT_PUBLIC_KEY_PATH\necho $FLOWPILOT_TOKEN_ISSUER\n\n# Restart service to reload key\ndocker compose restart flowpilot-domain-services-api\n</code></pre>"},{"location":"architecture/authentication/#token-expired","title":"Token Expired","text":"<p>Symptom: 401 Unauthorized - \"Token expired\"</p> <p>Solution: Client must exchange a fresh Firebase token:</p> <pre><code># Client refresh logic\nfirebase_token = await firebase.auth().currentUser.getIdToken(true)  # Force refresh\nresponse = await exchange_token(firebase_token)\nflowpilot_token = response[\"access_token\"]\n</code></pre>"},{"location":"architecture/authentication/#firebase-token-in-backend-call","title":"Firebase Token in Backend Call","text":"<p>Symptom: 401 Unauthorized - \"Invalid FlowPilot access token\"</p> <p>Cause: Client sending Firebase ID token instead of FlowPilot access token</p> <p>Solution: Ensure client exchanges Firebase token first:</p> <pre><code># \u274c WRONG - sending Firebase token to backend\nresponse = requests.post(\n    f\"{domain_services_api}/v1/workflows\",\n    headers={\"Authorization\": f\"Bearer {firebase_token}\"}  # Wrong!\n)\n\n# \u2705 CORRECT - exchange first, then use FlowPilot token\nflowpilot_token = exchange_for_flowpilot_token(firebase_token)\nresponse = requests.post(\n    f\"{domain_services_api}/v1/workflows\",\n    headers={\"Authorization\": f\"Bearer {flowpilot_token}\"}  # Correct!\n)\n</code></pre>"},{"location":"architecture/authentication/#best-practices","title":"Best Practices","text":""},{"location":"architecture/authentication/#development","title":"Development","text":"<ul> <li>\u2705 Use token exchange in all client applications</li> <li>\u2705 Test token expiry and refresh scenarios</li> <li>\u2705 Never commit signing keys or secrets</li> <li>\u2705 Use short-lived tokens (15 minutes or less)</li> <li>\u2705 Validate tokens on every backend request</li> </ul>"},{"location":"architecture/authentication/#production","title":"Production","text":"<ul> <li>\u2705 Use managed secrets (Google Secret Manager, AWS Secrets Manager)</li> <li>\u2705 Rotate signing keys periodically</li> <li>\u2705 Monitor authentication failures</li> <li>\u2705 Set appropriate token lifespans (balance security vs UX)</li> <li>\u2705 Use HTTPS everywhere</li> <li>\u274c Never use <code>verify=False</code> for TLS</li> <li>\u274c Never log tokens or PII</li> <li>\u274c Never store tokens in plaintext</li> <li>\u274c Never send Firebase tokens to backend services</li> </ul>"},{"location":"architecture/authentication/#privacy","title":"Privacy","text":"<ul> <li>\u2705 Always exchange Firebase tokens immediately</li> <li>\u2705 Use pseudonymous tokens (sub only) for all backend calls</li> <li>\u2705 Fetch persona attributes on-demand only when needed</li> <li>\u2705 Never log persona attributes</li> <li>\u2705 Limit persona data exposure to authz-api, persona-api, and OPA only</li> </ul>"},{"location":"architecture/authentication/#related-documentation","title":"Related Documentation","text":"<ul> <li>Authorization Architecture - How authorization decisions are made</li> <li>Persona Guide - Persona data model and lifecycle</li> <li>Security Overview - Overall security architecture</li> </ul>"},{"location":"architecture/authorization/","title":"Authorization Architecture","text":"<p>Authorization decisions in FlowPilot are persona-driven, not identity-driven.</p> <p>A persona represents the business role a subject assumes in a given context. A single person (principal) may have one or more personas, but each authorization request is evaluated against exactly one active persona.</p> <p>The <code>persona</code> attribute is therefore a core authorization input.</p>"},{"location":"architecture/authorization/#authorization-flow","title":"Authorization Flow","text":"<p>The complete authorization flow follows these steps:</p>"},{"location":"architecture/authorization/#1-request-arrives-at-pep","title":"1. Request Arrives at PEP","text":"<p>A request arrives at a Policy Enforcement Point (domain-services-api or ai-agent-api).</p>"},{"location":"architecture/authorization/#2-pep-constructs-authzen-request","title":"2. PEP Constructs AuthZEN Request","text":"<p>The PEP constructs an AuthZEN-compliant authorization request:</p> <pre><code>{\n  \"subject\": {\n    \"id\": \"agent-runner\",\n    \"persona\": \"ai-agent\"\n  },\n  \"action\": {\n    \"name\": \"execute\"\n  },\n  \"resource\": {\n    \"type\": \"workflow_item\",\n    \"id\": \"i_abc123\",\n    \"workflow_id\": \"w_xyz789\"\n  },\n  \"context\": {\n    \"principal\": {\n      \"id\": \"user-uuid\",\n      \"persona\": \"traveler\"\n    }\n  }\n}\n</code></pre>"},{"location":"architecture/authorization/#3-authz-api-validates-jwt","title":"3. AuthZ-API Validates JWT","text":"<p>The authz-api validates the bearer token:</p> <ul> <li>Validates using Firebase Admin SDK</li> <li>Verifies signature using Firebase public keys</li> <li>Checks issuer (Firebase), audience (project ID), expiry</li> <li>Extracts <code>uid</code> (mapped to <code>sub</code>) and custom claims</li> </ul>"},{"location":"architecture/authorization/#4-delegation-check-rebac","title":"4. Delegation Check (ReBAC)","text":"<p>If <code>subject.id \u2260 context.principal.id</code>, authz-api queries the delegation-api:</p> <ul> <li>Checks if a valid delegation exists</li> <li>Resolves delegation chains (transitive)</li> <li>Validates delegation scope and actions</li> </ul>"},{"location":"architecture/authorization/#5-policy-enrichment","title":"5. Policy Enrichment","text":"<p>Authz-api enriches the request with policy-relevant attributes:</p> <ul> <li>User consent flags</li> <li>Auto-booking preferences</li> <li>Risk thresholds</li> <li>Resource properties</li> </ul>"},{"location":"architecture/authorization/#6-opa-policy-evaluation-abac","title":"6. OPA Policy Evaluation (ABAC)","text":"<p>Enriched input is sent to OPA:</p> <ul> <li>OPA evaluates Rego policies</li> <li>Returns decision (allow/deny)</li> <li>Provides reason codes</li> </ul>"},{"location":"architecture/authorization/#7-decision-returned-to-pep","title":"7. Decision Returned to PEP","text":"<p>Authz-api returns structured response:</p> <pre><code>{\n  \"decision\": true,\n  \"reason\": \"Delegation valid and policy satisfied\"\n}\n</code></pre>"},{"location":"architecture/authorization/#8-pep-enforces-decision","title":"8. PEP Enforces Decision","text":"<p>The PEP grants or denies the requested action based on the decision.</p>"},{"location":"architecture/authorization/#autonomous-ai-booking-policy","title":"Autonomous AI Booking Policy","text":"<p>An <code>ai-agent</code> is allowed to book travel autonomously only when all of the following policy conditions are satisfied:</p> <ol> <li>The user has explicitly provided auto-book consent</li> <li>The total trip cost is less than or equal to the configured threshold (e.g., \u20ac1,500)</li> <li>The departure date is at least the configured lead time in the future (e.g., 7 days)</li> <li>The airline risk score is below the configured threshold</li> </ol> <p>These conditions are evaluated declaratively using OPA (ABAC) and are independent of delegation relationships.</p> <p>If any condition fails, autonomous booking is denied.</p>"},{"location":"architecture/authorization/#delegation-model","title":"Delegation Model","text":"<p>A user with persona <code>traveler</code> may delegate the execution of a booking workflow to users with one of the following personas:</p> <ul> <li><code>travel-agent</code></li> <li><code>office-manager</code></li> <li><code>booking-assistant</code></li> </ul> <p>Delegation is explicit, directional, and relationship-based (ReBAC).</p> <p>The delegation chain is validated and used by the attribute-based policy evaluation to make a decision.</p> <p>Delegation can also be done for read-only access, for example to invite co-travelers (both with the persona <code>traveler</code>).</p>"},{"location":"architecture/authorization/#authorization-scenarios","title":"Authorization Scenarios","text":"<p>The authorization layer distinguishes between the following scenarios:</p>"},{"location":"architecture/authorization/#1-owner-acting-directly-regular-user","title":"1. Owner Acting Directly (Regular User)","text":"<ul> <li>Subject is not an ai-agent</li> <li><code>subject.id == resource.owner.id</code></li> <li>No delegation needed</li> </ul>"},{"location":"architecture/authorization/#2-owner-acting-via-an-agent-runner","title":"2. Owner Acting via an Agent-Runner","text":"<ul> <li>Subject is an ai-agent</li> <li><code>context.principal.id == resource.owner.id</code></li> <li>Agent acts on direct behalf of user</li> </ul>"},{"location":"architecture/authorization/#3-autonomous-ai-agent","title":"3. Autonomous AI Agent","text":"<ul> <li>Subject is an ai-agent</li> <li>Auto-book consent is present</li> <li>Policy conditions satisfied</li> <li>No delegation relationship required</li> </ul>"},{"location":"architecture/authorization/#4-delegated-execution","title":"4. Delegated Execution","text":"<ul> <li>A valid delegation exists between principal and subject</li> <li>Delegation includes the required action (e.g., <code>execute</code>, <code>read</code>)</li> <li>May involve transitive delegation chains</li> </ul>"},{"location":"architecture/authorization/#from-authzen-request-to-opa-input","title":"From AuthZEN Request to OPA Input","text":"<p>The authz-api translates intent into decision-ready authorization claims.</p>"},{"location":"architecture/authorization/#authzen-payload-pep-authz-api","title":"AuthZEN Payload (PEP \u2192 AuthZ API)","text":"<p>The PEP sends a lightweight, portable request:</p> <pre><code>{\n  \"subject\": {\n    \"type\": \"agent\",\n    \"id\": \"agent-runner\",\n    \"persona\": \"ai-agent\"\n  },\n  \"action\": {\"name\": \"execute\"},\n  \"resource\": {\n    \"type\": \"workflow_item\",\n    \"id\": \"i_bc722d96\",\n    \"properties\": {\n      \"workflow_id\": \"w_771ab24f\",\n      \"planned_price\": 500.0,\n      \"departure_date\": \"2026-01-30\",\n      \"airline_risk_score\": 7,\n      \"owner\": {\n        \"id\": \"user-uuid\",\n        \"persona\": \"traveler\"\n      }\n    }\n  },\n  \"context\": {\n    \"principal\": {\n      \"id\": \"agent-uuid\",\n      \"persona\": \"travel-agent\"\n    }\n  }\n}\n</code></pre> <p>Key characteristics:</p> <ul> <li>Lightweight - no PII, no policy parameters</li> <li>Portable - works across PDP implementations</li> <li>Expresses intent and context, not policy</li> </ul>"},{"location":"architecture/authorization/#enriched-opa-input-authz-api-opa","title":"Enriched OPA Input (AuthZ API \u2192 OPA)","text":"<p>Before calling OPA, authz-api enriches the request:</p> <pre><code>{\n  \"subject\": {\n    \"type\": \"agent\",\n    \"id\": \"agent-runner\",\n    \"persona\": \"ai-agent\"\n  },\n  \"action\": {\"name\": \"execute\"},\n  \"resource\": {\n    \"type\": \"workflow_item\",\n    \"id\": \"i_bc722d96\",\n    \"properties\": {\n      \"workflow_id\": \"w_771ab24f\",\n      \"planned_price\": 500.0,\n      \"departure_date\": \"2026-01-30T00:00:00Z\",\n      \"airline_risk_score\": 7.0,\n      \"owner\": {\n        \"id\": \"user-uuid\",\n        \"persona\": \"traveler\",\n        \"autobook_consent\": true,\n        \"autobook_price\": 10000,\n        \"autobook_leadtime\": 7,\n        \"autobook_risklevel\": 5\n      }\n    }\n  },\n  \"context\": {\n    \"delegation\": {\n      \"valid\": true,\n      \"delegation_chain\": [\"user-uuid-1\", \"user-uuid-2\"],\n      \"delegated_actions\": [\"read\", \"execute\"]\n    },\n    \"principal\": {\n      \"id\": \"agent-uuid\",\n      \"persona\": \"travel-agent\"\n    }\n  }\n}\n</code></pre>"},{"location":"architecture/authorization/#enrichment-steps","title":"Enrichment Steps","text":"<p>1. Delegation (PIP for ReBAC)</p> <ul> <li>A <code>context.delegation</code> block is added</li> <li>Captures:</li> <li>Whether delegation is valid</li> <li>The resolved delegation chain</li> <li>The actions granted by delegation</li> <li>OPA does not resolve delegation itself; it consumes the result</li> </ul> <p>2. Policy Attributes (PIP for ABAC)</p> <p>Additional attributes are injected:</p> <ul> <li><code>autobook_consent</code> - User consent flag</li> <li><code>autobook_price</code> - Maximum price threshold</li> <li><code>autobook_leadtime</code> - Minimum lead time (days)</li> <li><code>autobook_risklevel</code> - Risk tolerance level</li> </ul> <p>These values:</p> <ul> <li>Are derived from user profiles</li> <li>Contain no PII</li> <li>Are normalized to types suitable for Rego evaluation</li> </ul> <p>3. Normalization and Hardening</p> <ul> <li>Dates converted to RFC 3339 timestamps</li> <li>Numeric values coerced to numbers</li> <li>Optional fields have consistent types or are absent</li> <li>Policy evaluation receives deterministic, safe input</li> </ul>"},{"location":"architecture/authorization/#why-this-separation-matters","title":"Why This Separation Matters","text":"<ul> <li>AuthZEN payloads express intent and context</li> <li>OPA input documents express decision-ready facts</li> <li>The translation layer:</li> <li>Enforces security invariants</li> <li>Prevents PII leakage</li> <li>Shields policies from upstream variability</li> </ul> <p>This design keeps:</p> <ul> <li>PEPs simple - Minimal authorization logic</li> <li>Policies declarative - Distinct review, approval, and release cycle</li> <li>Privacy preserved - No PII in policy decisions</li> <li>Authorization explainable - Clear audit trail</li> </ul>"},{"location":"architecture/authorization/#summary","title":"Summary","text":"<ul> <li>Personas define what role a subject plays</li> <li>Delegation defines who may act for whom</li> <li>OPA policies define under which conditions actions are allowed</li> <li>Autonomous AI execution is strictly gated and opt-in</li> </ul> <p>Together, these mechanisms ensure that authorization decisions are:</p> <ul> <li>Explicit</li> <li>Explainable</li> <li>Privacy-preserving</li> <li>Safe for agent-based execution</li> </ul>"},{"location":"architecture/authorization/#references","title":"References","text":"<ul> <li>API Reference: Authz API - Full API specification</li> <li>Policy Development Guide - How OPA policies use persona data</li> <li>Persona Development Guide - How personas and delegation are managed</li> <li>Authentication Architecture - Overall access token flow</li> </ul>"},{"location":"architecture/cors/","title":"CORS Configuration","text":"<p>FlowPilot services support Cross-Origin Resource Sharing (CORS) to enable web applications running in browsers to access the APIs.</p>"},{"location":"architecture/cors/#overview","title":"Overview","text":"<p>CORS is required when your web application's frontend (e.g., running on <code>https://app.example.com</code>) needs to make requests to FlowPilot APIs (running on different domains like <code>https://flowpilot-domain-services-api-*.run.app</code>).</p> <p>All five FlowPilot services include CORS middleware: - authz-api (port 8002 local, GCP Cloud Run) - domain-services-api (port 8003 local, GCP Cloud Run) - delegation-api (port 8005 local, GCP Cloud Run) - persona-api (port 8006 local, GCP Cloud Run) - ai-agent-api (port 8004 local, GCP Cloud Run)</p>"},{"location":"architecture/cors/#configuration","title":"Configuration","text":"<p>CORS behavior is controlled via environment variables in the shared <code>security.py</code> library:</p>"},{"location":"architecture/cors/#environment-variables","title":"Environment Variables","text":"Variable Description Default Example <code>CORS_ALLOWED_ORIGINS</code> Comma-separated list of allowed origins, or <code>*</code> for all <code>*</code> <code>https://app.example.com,https://admin.example.com</code> <code>CORS_ALLOW_CREDENTIALS</code> Allow credentials (cookies, auth headers) <code>true</code> <code>true</code> or <code>false</code> <code>CORS_ALLOW_METHODS</code> Allowed HTTP methods, or <code>*</code> for all <code>*</code> <code>GET,POST,PUT,DELETE</code> <code>CORS_ALLOW_HEADERS</code> Allowed headers, or <code>*</code> for all <code>*</code> <code>Authorization,Content-Type</code>"},{"location":"architecture/cors/#local-development-docker-compose","title":"Local Development (Docker Compose)","text":"<p>All services are configured with permissive CORS settings in <code>docker-compose.yml</code>:</p> <pre><code>environment:\n  - CORS_ALLOWED_ORIGINS=*\n  - CORS_ALLOW_CREDENTIALS=true\n  - CORS_ALLOW_METHODS=*\n  - CORS_ALLOW_HEADERS=*\n</code></pre> <p>This allows any web application running on localhost (e.g., <code>http://localhost:3000</code>, <code>http://localhost:5173</code>) to access the APIs during development.</p>"},{"location":"architecture/cors/#production-gcp-cloud-run","title":"Production (GCP Cloud Run)","text":"<p>CORS settings for production are defined in <code>cloud-run-envs/*.yaml</code> files:</p> <ul> <li><code>cloud-run-envs/authz-api.yaml</code></li> <li><code>cloud-run-envs/domain-services-api.yaml</code></li> <li><code>cloud-run-envs/delegation-api.yaml</code></li> <li><code>cloud-run-envs/persona-api.yaml</code></li> <li><code>cloud-run-envs/ai-agent-api.yaml</code></li> </ul>"},{"location":"architecture/cors/#default-production-settings","title":"Default Production Settings","text":"<p>Currently configured with permissive settings for development/testing:</p> <pre><code>CORS_ALLOWED_ORIGINS: \"*\"\nCORS_ALLOW_CREDENTIALS: \"true\"\nCORS_ALLOW_METHODS: \"*\"\nCORS_ALLOW_HEADERS: \"*\"\n</code></pre>"},{"location":"architecture/cors/#recommended-production-settings","title":"Recommended Production Settings","text":"<p>For production deployments, restrict origins to your actual web application domains:</p> <pre><code># Example: Production CORS configuration\nCORS_ALLOWED_ORIGINS: \"https://app.example.com,https://admin.example.com\"\nCORS_ALLOW_CREDENTIALS: \"true\"\nCORS_ALLOW_METHODS: \"GET,POST,PUT,DELETE\"\nCORS_ALLOW_HEADERS: \"Authorization,Content-Type,X-Request-ID\"\n</code></pre>"},{"location":"architecture/cors/#security-considerations","title":"Security Considerations","text":""},{"location":"architecture/cors/#development-vs-production","title":"Development vs. Production","text":"<p>Development: - Using <code>CORS_ALLOWED_ORIGINS=*</code> is acceptable for local development - Simplifies testing with various frontend frameworks and ports</p> <p>Production: - Never use <code>*</code> in production - this allows any website to access your APIs - Specify exact origins (protocol + domain + port if non-standard) - Use HTTPS origins only (except localhost for development)</p>"},{"location":"architecture/cors/#credentials-and-wildcard-origins","title":"Credentials and Wildcard Origins","text":"<p>Important: When <code>CORS_ALLOW_CREDENTIALS=true</code>, you cannot use <code>CORS_ALLOWED_ORIGINS=*</code> according to the CORS specification. Browsers will reject such requests.</p> <p>If you need credentials (JWT tokens in <code>Authorization</code> header), you must specify exact origins:</p> <pre><code># \u2705 Correct: specific origins with credentials\nCORS_ALLOWED_ORIGINS: \"https://app.example.com\"\nCORS_ALLOW_CREDENTIALS: \"true\"\n\n# \u274c Incorrect: wildcard with credentials (browsers reject)\nCORS_ALLOWED_ORIGINS: \"*\"\nCORS_ALLOW_CREDENTIALS: \"true\"\n</code></pre>"},{"location":"architecture/cors/#best-practices","title":"Best Practices","text":"<ol> <li>Restrict Origins: Only allow your actual frontend application domains</li> <li>Use HTTPS: Production origins should use HTTPS (except localhost for dev)</li> <li>Limit Methods: Only allow HTTP methods your API actually uses</li> <li>Limit Headers: Only allow headers your API requires</li> <li>Monitor: Log CORS errors to detect misconfiguration or unauthorized access attempts</li> </ol>"},{"location":"architecture/cors/#updating-cors-settings","title":"Updating CORS Settings","text":""},{"location":"architecture/cors/#local-development","title":"Local Development","text":"<ol> <li>Edit <code>docker-compose.yml</code> for the relevant service(s)</li> <li>Rebuild and restart:    <pre><code>docker compose up -d --build flowpilot-domain-services-api\n</code></pre></li> </ol>"},{"location":"architecture/cors/#gcp-cloud-run","title":"GCP Cloud Run","text":"<ol> <li>Edit the relevant <code>cloud-run-envs/*.yaml</code> file</li> <li>Rebuild the service (triggers image rebuild with new shared library):    <pre><code>gcloud builds submit --config=cloudbuild-domain-services-api.yaml\n</code></pre></li> <li>Redeploy with updated environment variables:    <pre><code>gcloud run deploy flowpilot-domain-services-api \\\n  --image=us-central1-docker.pkg.dev/vision-course-476214/flowpilot/flowpilot-domain-services-api:latest \\\n  --region=us-central1 \\\n  --platform=managed \\\n  --env-vars-file=cloud-run-envs/domain-services-api.yaml\n</code></pre></li> </ol>"},{"location":"architecture/cors/#testing-cors","title":"Testing CORS","text":""},{"location":"architecture/cors/#browser-devtools","title":"Browser DevTools","text":"<ol> <li>Open your web application in a browser</li> <li>Open DevTools \u2192 Network tab</li> <li>Make a request to a FlowPilot API</li> <li>Check the response headers for:    <pre><code>access-control-allow-origin: https://your-app.example.com\naccess-control-allow-credentials: true\naccess-control-allow-methods: GET, POST, PUT, DELETE\naccess-control-allow-headers: authorization, content-type\n</code></pre></li> </ol>"},{"location":"architecture/cors/#cors-preflight-requests","title":"CORS Preflight Requests","text":"<p>For requests with custom headers (like <code>Authorization</code>), browsers send a preflight <code>OPTIONS</code> request:</p> <pre><code># Example preflight request\ncurl -X OPTIONS http://localhost:8003/v1/workflows \\\n  -H \"Origin: http://localhost:3000\" \\\n  -H \"Access-Control-Request-Method: POST\" \\\n  -H \"Access-Control-Request-Headers: authorization,content-type\" \\\n  -v\n</code></pre> <p>You should see CORS headers in the response.</p>"},{"location":"architecture/cors/#common-cors-errors","title":"Common CORS Errors","text":"<p>Error: \"Access to fetch at '...' from origin '...' has been blocked by CORS policy\"</p> <p>Causes: 1. Origin not in <code>CORS_ALLOWED_ORIGINS</code> 2. Using <code>*</code> with <code>CORS_ALLOW_CREDENTIALS=true</code> 3. Missing required header in <code>CORS_ALLOW_HEADERS</code> 4. Service not configured with CORS middleware (should not happen in FlowPilot)</p> <p>Solution: - Check environment variables in running service - Verify origin matches exactly (including protocol and port) - Check browser DevTools \u2192 Console for specific CORS error details</p>"},{"location":"architecture/cors/#implementation-details","title":"Implementation Details","text":"<p>CORS is implemented in <code>flowpilot-services/shared-libraries/security.py</code>:</p> <pre><code>def get_cors_config() -&gt; dict[str, Any]:\n    \"\"\"\n    Get CORS configuration from environment variables.\n    Returns dict suitable for passing to CORSMiddleware constructor.\n    \"\"\"\n    origins_str = os.environ.get(\"CORS_ALLOWED_ORIGINS\", \"*\")\n    origins = [o.strip() for o in origins_str.split(\",\")] if origins_str != \"*\" else [\"*\"]\n\n    allow_credentials = os.environ.get(\"CORS_ALLOW_CREDENTIALS\", \"true\").lower() == \"true\"\n\n    methods_str = os.environ.get(\"CORS_ALLOW_METHODS\", \"*\")\n    methods = [m.strip() for m in methods_str.split(\",\")] if methods_str != \"*\" else [\"*\"]\n\n    headers_str = os.environ.get(\"CORS_ALLOW_HEADERS\", \"*\")\n    headers = [h.strip() for h in headers_str.split(\",\")] if headers_str != \"*\" else [\"*\"]\n\n    return {\n        \"allow_origins\": origins,\n        \"allow_credentials\": allow_credentials,\n        \"allow_methods\": methods,\n        \"allow_headers\": headers,\n    }\n</code></pre> <p>Each service applies CORS middleware in its FastAPI app initialization:</p> <pre><code>from fastapi.middleware.cors import CORSMiddleware\nimport security\n\n# Add CORS middleware\ncors_config = security.get_cors_config()\napp.add_middleware(\n    CORSMiddleware,\n    allow_origins=cors_config[\"allow_origins\"],\n    allow_credentials=cors_config[\"allow_credentials\"],\n    allow_methods=cors_config[\"allow_methods\"],\n    allow_headers=cors_config[\"allow_headers\"],\n)\n</code></pre>"},{"location":"architecture/cors/#related-documentation","title":"Related Documentation","text":"<ul> <li>Integration Guide - Web application integration examples</li> <li>Security Architecture - Overall security model</li> <li>Deployment Guide - GCP Cloud Run deployment with CORS</li> </ul>"},{"location":"architecture/overview/","title":"Architecture Overview","text":"<p>FlowPilot is a reference implementation of a modern authorization architecture for agentic workflows. It demonstrates how to build secure, privacy-preserving systems that combine relationship-based access control (ReBAC) with attribute-based policy decisions (ABAC).</p>"},{"location":"architecture/overview/#what-flowpilot-is","title":"What FlowPilot Is","text":"<p>FlowPilot is:</p> <ul> <li>A realistic, end-to-end authorization architecture - Complete implementation from authentication to policy decisions</li> <li>A working example of PEP \u2194 PDP separation - Using AuthZEN as the interface layer</li> <li>A demonstration of ABAC + ReBAC - Combined coherently in a single system</li> <li>A foundation for agent-based systems - With strong authorization guarantees</li> </ul>"},{"location":"architecture/overview/#what-flowpilot-is-not","title":"What FlowPilot Is Not","text":"<p>FlowPilot is not:</p> <ul> <li>A production-ready travel platform - Travel booking is used as a concrete metaphor</li> <li>An IAM product - This is a reference architecture, not a commercial product</li> <li>A UI-first demo - Focus is on backend authorization patterns</li> <li>An AI showcase - AI is used to demonstrate agentic authorization, not as the primary focus</li> </ul>"},{"location":"architecture/overview/#conceptual-pillars","title":"Conceptual Pillars","text":""},{"location":"architecture/overview/#1-authzen-as-the-pep-pdp-contract","title":"1. AuthZEN as the PEP \u2194 PDP Contract","text":"<p>FlowPilot treats AuthZEN as the interface, not the implementation.</p> <p>Policy Enforcement Points (PEPs) submit AuthZEN-like requests:</p> <ul> <li><code>subject</code> - Who or what is performing the action</li> <li><code>action</code> - What operation is being attempted</li> <li><code>resource</code> - What is being acted upon</li> <li><code>context</code> - Additional context for the decision</li> </ul> <p>The Policy Decision Point (PDP) via flowpilot-authz-api:</p> <ul> <li>Enriches the request with additional data</li> <li>Consults Policy Information Points (PIPs)</li> <li>Evaluates policies using OPA</li> <li>Returns structured authorization decisions</li> </ul> <p>This separation keeps:</p> <ul> <li>Application services simple</li> <li>Authorization logic centralized</li> <li>The system evolvable without rewriting PEPs</li> </ul>"},{"location":"architecture/overview/#2-rebac-with-explicit-delegation-relationships","title":"2. ReBAC with Explicit Delegation Relationships","text":"<p>Delegation is modeled as a relationship graph, not as token bloat.</p> <p>The <code>flowpilot-delegation-api</code> acts as a ReBAC PIP:</p> <ul> <li>Delegations are explicit: principal \u2192 delegate relationships</li> <li>Delegations can be:</li> <li>Workflow-scoped or global</li> <li>Time-bound</li> <li>Revocable</li> <li>Delegation chains are resolved transitively: A \u2192 B \u2192 C \u2192 D</li> <li>Chain length is bounded to prevent privilege amplification</li> </ul>"},{"location":"architecture/overview/#3-opa-as-a-declarative-policy-engine-abac","title":"3. OPA as a Declarative Policy Engine (ABAC)","text":"<p>OPA is used strictly for attribute-based policy decisions:</p> <ul> <li>Policies are written in Rego - Declarative policy language</li> <li>Policies are evaluated in OPA server mode - No embedded decision logic</li> <li>Policies are:</li> <li>Declarative</li> <li>Testable</li> <li>Explainable</li> </ul> <p>OPA answers questions such as:</p> <ul> <li>Is the user allowed and properly delegated to auto-execute a workflow?</li> <li>Is consent for executing a workflow present?</li> <li>Is the risk of executing a workflow item below the configured threshold?</li> </ul> <p>OPA itself uses AuthZEN-enriched input and does not need to manage identity, delegation graphs, or relationships.</p>"},{"location":"architecture/overview/#4-bearer-tokens-with-personas-not-identity-payloads","title":"4. Bearer Tokens with Personas, Not Identity Payloads","text":"<p>Access-tokens intentionally carry minimal personal information.</p> <p>Tokens contain:</p> <ul> <li><code>sub</code> - Stable, pseudonymous UUID</li> <li>Technical claims (issuer, expiry, crypto validation)</li> </ul> <p>Tokens do NOT contain:</p> <ul> <li>Names</li> <li>Usernames</li> <li>Email addresses</li> <li>Personal preferences</li> <li>Consent details</li> <li>Any other PII</li> </ul> <p>Benefits:</p> <ul> <li>Tokens remain small and stable</li> <li>Privacy is preserved by design</li> <li>Authorization decisions pull data only when needed</li> <li>The token provides just enough information to identify the principal</li> </ul>"},{"location":"architecture/overview/#travel-booking-as-a-workflow-metaphor","title":"Travel Booking as a Workflow Metaphor","text":"<p>The travel domain is used as a concrete narrative, not a limitation.</p> <p>Conceptual Mapping:</p> <ul> <li>A trip is a workflow</li> <li>Booking steps are workflow items</li> <li>A human booking is a principal</li> <li>Travelers can delegate actions to travel agents and AI agents</li> <li>Delegated parties can further delegate to other parties</li> <li>Auto-execution preferences provide policy-driven constraints</li> </ul> <p>This maps cleanly to other domains:</p> <ul> <li>Financial approvals</li> <li>Medical record handling</li> <li>Case management</li> <li>Enterprise automation</li> <li>Agent-based task execution</li> </ul> <p>The travel example exists to make the architecture tangible, not to constrain it.</p>"},{"location":"architecture/overview/#microservices-architecture","title":"Microservices Architecture","text":"<p>FlowPilot consists of multiple microservices, each with a specific responsibility:</p>"},{"location":"architecture/overview/#flowpilot-authz-api-port-8002","title":"flowpilot-authz-api (Port 8002)","text":"<p>Authorization fa\u00e7ade (PEP \u2194 PDP integration):</p> <ul> <li>Validates AuthZEN requests</li> <li>Validates bearer tokens via JWKS</li> <li>Enforces delegation (ReBAC)</li> <li>Evaluates policies via OPA (ABAC)</li> <li>Returns allow/deny with reason codes</li> </ul>"},{"location":"architecture/overview/#flowpilot-persona-api-port-8006","title":"flowpilot-persona-api (Port 8006)","text":"<p>Persona management:</p> <ul> <li>Manages persona definitions</li> <li>Normlaizes and defaults attributes</li> <li>No policy logic</li> <li>No PII</li> <li>Implements a record per persona referring to the identity using <code>sub</code></li> </ul>"},{"location":"architecture/overview/#flowpilot-delegation-api-port-8005","title":"flowpilot-delegation-api (Port 8005)","text":"<p>Delegation relationship management:</p> <ul> <li>Manages delegation relationships</li> <li>Resolves delegation chains</li> <li>No policy logic</li> <li>No PII</li> <li>Implements a directional graph</li> </ul>"},{"location":"architecture/overview/#opa-server-port-8181","title":"OPA server (Port 8181)","text":"<p>Declarative policy engine:</p> <ul> <li>Evaluates Rego policies</li> <li>Stateless decision engine</li> <li>Policies mounted from filesystem</li> </ul>"},{"location":"architecture/overview/#firebase-authentication","title":"Firebase Authentication","text":"<p>Identity provider (fully managed):</p> <ul> <li>Issues Firebase ID tokens (JWTs)</li> <li>Personas stored in Firestore and custom claims</li> <li>Tokens validated locally by services using Firebase Admin SDK</li> <li>Automatic key rotation and management</li> </ul>"},{"location":"architecture/overview/#flowpilot-domain-services-api-port-8003","title":"flowpilot-domain-services-api (Port 8003)","text":"<p>Workflow domain logic (PEP):</p> <ul> <li>Creates and manages workflows</li> <li>System of record for travel bookings</li> <li>Calls authz-api for authorization checks</li> <li>Auto-creates delegations</li> </ul>"},{"location":"architecture/overview/#flowpilot-ai-agent-api-port-8004","title":"flowpilot-ai-agent-api (Port 8004)","text":"<p>AI agent execution (PEP):</p> <ul> <li>Executes workflow items on behalf of users</li> <li>Demonstrates agentic authorization patterns</li> <li>Service-to-service authentication</li> </ul>"},{"location":"architecture/overview/#privacy-by-design","title":"Privacy by Design","text":"<p>Privacy is not an afterthought; it is structural:</p> <ul> <li>No PII in tokens - Only pseudonymous identifiers</li> <li>No PII passed to AI agents - Only workflow context</li> <li>Delegation graph uses identifiers only - No personal information</li> <li>Profiles expose presence flags, not values - Consent without details</li> <li>Authorization decisions are reproducible - Without identity data</li> </ul> <p>The result:</p> <ul> <li>Minimal data surface</li> <li>Lower breach impact</li> <li>Clearer compliance story</li> </ul>"},{"location":"architecture/overview/#security-by-architecture","title":"Security by Architecture","text":"<p>Security is enforced at multiple layers:</p> <ul> <li>JWT validation - Signature, issuer, audience, exp, nbf, iat, typ</li> <li>JWKS-based local validation - No network calls per request</li> <li>Strict AuthZEN request validation - Schema enforcement</li> <li>Full payload sanitization - Input validation at every boundary</li> <li>Fail-closed behavior - Everywhere by default</li> </ul> <p>The system assumes inputs are hostile by default.</p>"},{"location":"architecture/overview/#why-this-matters","title":"Why This Matters","text":"<p>Most \"agentic\" demos ignore authorization, privacy, and delegation until late.</p> <p>FlowPilot does the opposite:</p> <ul> <li>Authorization is central - Not bolted on</li> <li>Delegation is explicit - Not implicit or token-based</li> <li>Policy is declarative - Not hard-coded</li> <li>Identity data is minimized - By design</li> </ul> <p>This repository is meant to be read, reasoned about, and adapted, not just run.</p>"},{"location":"architecture/security/","title":"Security Architecture","text":"<p>FlowPilot implements defense-in-depth security with multiple layers of protection at every boundary.</p>"},{"location":"architecture/security/#security-principles","title":"Security Principles","text":"<p>The system is built on the following security principles:</p> <ol> <li>Fail-closed by default - Deny unless explicitly allowed</li> <li>Zero trust - Validate every request at every boundary</li> <li>Minimal PII exposure - Only process pseudonymous identifiers</li> <li>Defense-in-depth - Multiple security layers</li> <li>Explicit authorization - Never assume permissions</li> </ol>"},{"location":"architecture/security/#defense-in-depth-layers","title":"Defense-in-Depth Layers","text":""},{"location":"architecture/security/#layer-1-jwt-validation","title":"Layer 1: JWT Validation","text":"<p>All services validate bearer tokens using Firebase Admin SDK:</p> <p>Validation checks (performed by Firebase Admin SDK):</p> <ul> <li>Signature verification - Using Firebase public keys</li> <li>Issuer validation - Must be Firebase (<code>securetoken.google.com</code>)</li> <li>Audience validation - Must match Firebase project ID</li> <li>Expiry check - Token must not be expired (<code>exp</code> claim)</li> <li>Issued-at check - Token must have valid issue time (<code>iat</code> claim)</li> <li>Authentication time - Validates <code>auth_time</code> claim</li> </ul> <p>Benefits:</p> <ul> <li>Zero network calls per request - Public keys cached by SDK</li> <li>High performance - Local cryptographic verification</li> <li>Resilient - No dependency on Firebase servers for validation</li> <li>Automatic key rotation - SDK handles Firebase key updates</li> </ul> <p>Implementation pattern:</p> <pre><code>from fastapi import Depends\nimport security\n\ndef get_token_claims(\n    token_claims: dict = Depends(security.verify_token)\n) -&gt; dict:\n    return token_claims\n\n@app.post(\"/endpoint\")\ndef handler(token_claims: dict = Depends(get_token_claims)):\n    user_sub = token_claims[\"sub\"]\n    # Use validated claims\n</code></pre>"},{"location":"architecture/security/#layer-2-input-validation","title":"Layer 2: Input Validation","text":"<p>Four-layer input validation approach:</p> <p>1. Pydantic Model Validation</p> <ul> <li>Type validation</li> <li>Field presence checks</li> <li>Range validation</li> <li>Format validation</li> </ul> <p>2. Path Parameter Validation</p> <ul> <li>Parameter type enforcement</li> <li>Required parameter checks</li> <li>Pattern matching</li> </ul> <p>3. String Sanitization</p> <ul> <li>Control character rejection</li> <li>Maximum length enforcement</li> <li>Pattern validation</li> <li>Unicode normalization</li> </ul> <p>4. Request Size Limits</p> <ul> <li>Default: 1MB maximum request size</li> <li>Configurable via <code>MAX_REQUEST_SIZE_MB</code></li> <li>Prevents denial-of-service attacks</li> </ul> <p>Implementation pattern:</p> <pre><code>import security\n\ntry:\n    sanitized = security.sanitize_request_json_payload(request_body)\nexcept security.InputValidationError as e:\n    raise HTTPException(status_code=400, detail=str(e))\n</code></pre>"},{"location":"architecture/security/#layer-3-injection-prevention","title":"Layer 3: Injection Prevention","text":"<p>Attack Pattern Detection:</p> <ul> <li>Optional signature scanning for common attack patterns</li> <li>Configurable via <code>ENABLE_PAYLOAD_SIGNATURE_SCAN</code></li> <li>Detects SQL injection, command injection, XSS attempts</li> </ul> <p>Control Character Rejection:</p> <ul> <li>All string inputs sanitized</li> <li>Control characters stripped or rejected</li> <li>Prevents payload smuggling attacks</li> </ul>"},{"location":"architecture/security/#layer-4-security-headers","title":"Layer 4: Security Headers","text":"<p>Six protective headers on all HTTP responses:</p> <ol> <li><code>X-Content-Type-Options: nosniff</code> - Prevents MIME sniffing</li> <li><code>X-Frame-Options: DENY</code> - Prevents clickjacking</li> <li><code>X-XSS-Protection: 1; mode=block</code> - Enables XSS protection</li> <li><code>Strict-Transport-Security: max-age=31536000</code> - Enforces HTTPS</li> <li><code>Content-Security-Policy: default-src 'self'</code> - Restricts resource loading</li> <li><code>Referrer-Policy: no-referrer</code> - Prevents referrer leakage</li> </ol>"},{"location":"architecture/security/#layer-5-error-handling","title":"Layer 5: Error Handling","text":"<p>Production-safe error messages:</p> <ul> <li>Development mode (<code>INCLUDE_ERROR_DETAILS=1</code>): Detailed error messages</li> <li>Production mode (<code>INCLUDE_ERROR_DETAILS=0</code>): Sanitized error messages</li> <li>No stack traces exposed to clients</li> <li>No internal paths or configuration leaked</li> </ul> <p>Implementation:</p> <pre><code>INCLUDE_ERROR_DETAILS = os.environ.get(\"INCLUDE_ERROR_DETAILS\", \"1\") == \"1\"\n\ntry:\n    # ... operation ...\nexcept Exception as exc:\n    error_detail = security.sanitize_error_message(\n        str(exc), \n        INCLUDE_ERROR_DETAILS\n    )\n    raise HTTPException(status_code=500, detail=error_detail)\n</code></pre>"},{"location":"architecture/security/#layer-6-pii-protection","title":"Layer 6: PII Protection","text":"<p>Zero PII exposure:</p> <ul> <li>Tokens contain only <code>sub</code> (UUID) - No names, emails, or personal data</li> <li>Logs use pseudonymous identifiers - No PII in application logs</li> <li>Authorization decisions use UUIDs - No identity data in policy evaluation</li> <li>AI agents never see PII - Only workflow context and pseudonymous IDs</li> </ul> <p>Benefits:</p> <ul> <li>Minimal data surface for breaches</li> <li>Simplified compliance (GDPR, CCPA)</li> <li>Lower forensic costs</li> <li>Reproducible authorization without identity data</li> </ul>"},{"location":"architecture/security/#shared-security-library","title":"Shared Security Library","text":"<p>All security utilities are centralized in the shared library:</p> <p>Location: <code>flowpilot-services/shared-libraries/security.py</code></p> <p>Provides:</p> <ul> <li><code>verify_token()</code> - JWKS-based JWT validation</li> <li><code>sanitize_request_json_payload()</code> - Input sanitization</li> <li><code>sanitize_string()</code> - String sanitization</li> <li><code>sanitize_error_message()</code> - Error message sanitization</li> <li><code>SecurityHeadersMiddleware</code> - Security headers middleware</li> <li><code>RequestSizeLimiterMiddleware</code> - Request size limiting</li> <li><code>get_cors_config()</code> - CORS configuration</li> </ul> <p>IMPORTANT: Changes to shared libraries require container rebuilds (files are copied at build time).</p>"},{"location":"architecture/security/#tls-and-certificate-management","title":"TLS and Certificate Management","text":""},{"location":"architecture/security/#local-development","title":"Local Development","text":"<p>Using mkcert for local TLS:</p> <pre><code># Install mkcert\nbrew install mkcert\n\n# Install local CA\nmkcert -install\n\n# Copy root CA to project\ncp \"$(mkcert -CAROOT)/rootCA.pem\" infra/certs/mkcert-rootCA.pem\n</code></pre> <p>Services use <code>verify=False</code> in development:</p> <pre><code># LOCAL DEV ONLY - NEVER IN PRODUCTION\nresponse = requests.post(\n    url,\n    data=data,\n    verify=False  # \u26a0\ufe0f Only for local development\n)\n</code></pre>"},{"location":"architecture/security/#production-deployment","title":"Production Deployment","text":"<ul> <li>Never use <code>verify=False</code> in production</li> <li>Use proper TLS certificates</li> <li>Configure certificate validation</li> <li>Enable HSTS headers</li> </ul>"},{"location":"architecture/security/#authentication-flows","title":"Authentication Flows","text":""},{"location":"architecture/security/#desktop-client-services","title":"Desktop Client \u2192 Services","text":"<p>Authorization Code + PKCE flow:</p> <ol> <li>User clicks login in desktop app</li> <li>App opens browser to Keycloak</li> <li>User authenticates</li> <li>Keycloak returns authorization code</li> <li>App exchanges code for access token (with PKCE)</li> <li>App uses access token for API calls</li> </ol> <p>Token characteristics:</p> <ul> <li>Short-lived (configurable)</li> <li>Contains <code>sub</code> and <code>persona</code> claims</li> <li>Validated locally by services</li> </ul>"},{"location":"architecture/security/#service-service","title":"Service \u2192 Service","text":"<p>Client Credentials flow:</p> <pre><code>def get_service_token():\n    response = requests.post(\n        os.environ[\"KEYCLOAK_TOKEN_URL\"],\n        data={\n            \"grant_type\": \"client_credentials\",\n            \"client_id\": os.environ[\"AGENT_CLIENT_ID\"],\n            \"client_secret\": os.environ[\"AGENT_CLIENT_SECRET\"],\n        },\n        verify=False  # Local dev only\n    )\n    return response.json()[\"access_token\"]\n</code></pre> <p>Service account: <code>flowpilot-agent</code></p>"},{"location":"architecture/security/#environment-configuration","title":"Environment Configuration","text":""},{"location":"architecture/security/#security-environment-variables","title":"Security Environment Variables","text":"<p>JWT Validation:</p> <p>Firebase Admin SDK uses Application Default Credentials (ADC) - no configuration needed on Cloud Run.</p> <p>For local development:</p> <pre><code>GOOGLE_APPLICATION_CREDENTIALS=/path/to/serviceAccountKey.json  # Optional\n</code></pre> <p>Input Validation:</p> <pre><code>ENABLE_PAYLOAD_SIGNATURE_SCAN=0  # 1 to enable attack signature scanning\nMAX_REQUEST_SIZE_MB=1\n</code></pre> <p>Error Handling:</p> <pre><code>INCLUDE_ERROR_DETAILS=1  # Set to 0 in production\n</code></pre> <p>Secrets (.env file - never commit):</p> <pre><code>KEYCLOAK_ADMIN_USERNAME=admin\nKEYCLOAK_ADMIN_PASSWORD=&lt;your-password&gt;\nKEYCLOAK_CLIENT_SECRET=&lt;your-secret&gt;\nAGENT_CLIENT_SECRET=&lt;your-secret&gt;\n</code></pre>"},{"location":"architecture/security/#security-best-practices","title":"Security Best Practices","text":""},{"location":"architecture/security/#development","title":"Development","text":"<ul> <li>\u2705 Use environment variables for configuration</li> <li>\u2705 Never commit <code>.env</code> file</li> <li>\u2705 Use mkcert for local TLS</li> <li>\u2705 Enable detailed errors for debugging</li> <li>\u2705 Test with malformed inputs</li> </ul>"},{"location":"architecture/security/#production","title":"Production","text":"<ul> <li>\u2705 Set <code>INCLUDE_ERROR_DETAILS=0</code></li> <li>\u2705 Set <code>ENABLE_PAYLOAD_SIGNATURE_SCAN=1</code></li> <li>\u2705 Use proper TLS certificates</li> <li>\u2705 Rotate secrets regularly</li> <li>\u2705 Monitor for unauthorized access attempts</li> <li>\u2705 Enable audit logging</li> <li>\u274c Never use <code>verify=False</code> for TLS</li> <li>\u274c Never expose internal error details</li> <li>\u274c Never log PII</li> </ul>"},{"location":"architecture/security/#code-reviews","title":"Code Reviews","text":"<p>When reviewing code, check for:</p> <ul> <li>JWT validation on all protected endpoints</li> <li>Input sanitization before processing</li> <li>Fail-closed authorization logic</li> <li>No PII in logs or error messages</li> <li>Proper use of security middleware</li> <li>No hard-coded secrets</li> </ul>"},{"location":"architecture/security/#threat-model","title":"Threat Model","text":"<p>The system is designed to defend against:</p>"},{"location":"architecture/security/#external-threats","title":"External Threats","text":"<ul> <li>Token theft - Mitigated by short-lived tokens and signature validation</li> <li>Replay attacks - Mitigated by token expiry and nonce validation</li> <li>Injection attacks - Mitigated by input sanitization</li> <li>XSS/CSRF - Mitigated by security headers</li> <li>Man-in-the-middle - Mitigated by TLS and certificate validation</li> </ul>"},{"location":"architecture/security/#internal-threats","title":"Internal Threats","text":"<ul> <li>Privilege escalation - Mitigated by explicit delegation and bounded chains</li> <li>Unauthorized access - Mitigated by fail-closed authorization</li> <li>Data exfiltration - Mitigated by minimal PII exposure</li> <li>Service impersonation - Mitigated by mutual TLS and token validation</li> </ul>"},{"location":"architecture/security/#audit-and-compliance","title":"Audit and Compliance","text":""},{"location":"architecture/security/#audit-logging","title":"Audit Logging","text":"<p>All authorization decisions are logged:</p> <ul> <li>Subject, action, resource</li> <li>Decision (allow/deny)</li> <li>Reason codes</li> <li>Timestamp</li> <li>Request ID</li> </ul>"},{"location":"architecture/security/#compliance-considerations","title":"Compliance Considerations","text":"<p>GDPR:</p> <ul> <li>Minimal PII by design</li> <li>Pseudonymous identifiers (UUIDs)</li> <li>Clear data minimization</li> <li>Explicit consent mechanisms</li> </ul> <p>SOC 2:</p> <ul> <li>Comprehensive audit logging</li> <li>Fail-closed security model</li> <li>Separation of duties (PEP/PDP)</li> <li>Input validation at boundaries</li> </ul>"},{"location":"architecture/security/#security-contact","title":"Security Contact","text":"<p>For security issues, see <code>SECURITY.md</code> for reporting procedures.</p>"},{"location":"architecture/services/","title":"Microservices Architecture","text":"<p>FlowPilot implements a microservices architecture with clear separation of concerns. Each service has a specific responsibility and communicates via REST APIs defined using OpenAPI.</p>"},{"location":"architecture/services/#service-overview","title":"Service Overview","text":"Service Port Type Purpose flowpilot-authz-api 8002 PDP Authorization decisions flowpilot-domain-services-api 8003 PEP Workflow management flowpilot-ai-agent-api 8004 PEP AI agent execution flowpilot-delegation-api 8005 PIP Delegation graph Firebase Authentication - IdP Identity provider OPA 8181 PDP Policy engine"},{"location":"architecture/services/#communication-patterns","title":"Communication Patterns","text":"<p>All services communicate through REST APIs:</p> <ul> <li>Protected by TLS - All inter-service communication uses TLS</li> <li>Bearer token authentication - JWT validation on all protected endpoints</li> <li>Input sanitization - All inputs validated before processing</li> <li>Fail-closed - Services deny by default</li> </ul>"},{"location":"architecture/services/#service-details","title":"Service Details","text":""},{"location":"architecture/services/#1-flowpilot-authz-api-port-8002","title":"1. flowpilot-authz-api (Port 8002)","text":"<p>Role: Policy Decision Point (PDP) and Authorization Fa\u00e7ade</p> <p>Responsibilities:</p> <ul> <li>Accepts AuthZEN-compliant authorization requests</li> <li>Validates bearer tokens via JWKS</li> <li>Enforces delegation by calling delegation-api (ReBAC)</li> <li>Evaluates ABAC policies via OPA</li> <li>Returns structured authorization decisions with reason codes</li> </ul> <p>Key Endpoints:</p> <ul> <li><code>POST /v1/evaluate</code> - Evaluate authorization request</li> <li><code>GET /health</code> - Health check</li> </ul> <p>Code Structure:</p> <pre><code>authz-api/\n\u251c\u2500\u2500 main.py          # FastAPI app and routes\n\u251c\u2500\u2500 core.py          # Authorization logic\n\u2514\u2500\u2500 Dockerfile       # Container definition\n</code></pre> <p>Key Files:</p> <ul> <li><code>main.py</code> - FastAPI application and route definitions</li> <li><code>core.py</code> - Core authorization logic and OPA integration</li> </ul> <p>Environment Variables:</p> <pre><code>OPA_URL=http://opa:8181\nDELEGATION_API_BASE_URL=http://flowpilot-delegation-api:8000\nKEYCLOAK_JWKS_URI=https://keycloak:8443/realms/flowpilot/protocol/openid-connect/certs\n</code></pre>"},{"location":"architecture/services/#2-flowpilot-delegation-api-port-8005","title":"2. flowpilot-delegation-api (Port 8005)","text":"<p>Role: Policy Information Point (PIP) for ReBAC</p> <p>Responsibilities:</p> <ul> <li>Manages delegation relationships (principal \u2192 delegate)</li> <li>Resolves delegation chains (transitive)</li> <li>Validates delegation scope and actions</li> <li>SQLite-backed persistence</li> <li>No policy logic - purely relationship management</li> <li>No PII - only pseudonymous identifiers</li> </ul> <p>Key Endpoints:</p> <ul> <li><code>POST /v1/delegations</code> - Create delegation</li> <li><code>GET /v1/delegations</code> - List delegations</li> <li><code>GET /v1/delegations/{id}</code> - Get delegation details</li> <li><code>DELETE /v1/delegations/{id}</code> - Revoke delegation</li> <li><code>POST /v1/delegations/validate</code> - Validate delegation chain</li> <li><code>GET /health</code> - Health check</li> </ul> <p>Code Structure:</p> <pre><code>delegation-api/\n\u251c\u2500\u2500 main.py          # FastAPI app and routes\n\u251c\u2500\u2500 core.py          # Delegation logic\n\u2514\u2500\u2500 Dockerfile       # Container definition\n</code></pre> <p>Data Model:</p> <p>Delegations are stored as directional edges in a graph:</p> <ul> <li><code>principal_id</code> - Who is delegating</li> <li><code>delegate_id</code> - Who is being delegated to</li> <li><code>workflow_id</code> - Optional workflow scope</li> <li><code>scope</code> - Actions granted (e.g., <code>[\"read\", \"execute\"]</code>)</li> <li><code>created_at</code> - Timestamp</li> <li><code>expires_at</code> - Optional expiry</li> </ul> <p>Delegation Chains:</p> <p>Transitive delegation is supported:</p> <ul> <li>A delegates to B</li> <li>B delegates to C</li> <li>C can act on behalf of A (if scope permits)</li> <li>Chain length is bounded to prevent privilege amplification</li> </ul>"},{"location":"architecture/services/#3-flowpilot-domain-services-api-port-8003","title":"3. flowpilot-domain-services-api (Port 8003)","text":"<p>Role: Policy Enforcement Point (PEP) for Workflow Domain</p> <p>Responsibilities:</p> <ul> <li>Creates and manages workflows (trips)</li> <li>Creates and manages workflow items (booking steps)</li> <li>System of record for travel booking workflows</li> <li>Calls authz-api for all authorization checks</li> <li>Auto-creates delegations when workflows are created</li> </ul> <p>Key Endpoints:</p> <ul> <li><code>POST /v1/workflows</code> - Create workflow</li> <li><code>GET /v1/workflows</code> - List workflows</li> <li><code>GET /v1/workflows/{id}</code> - Get workflow details</li> <li><code>POST /v1/workflows/{id}/items</code> - Create workflow item</li> <li><code>GET /v1/workflows/{id}/items</code> - List workflow items</li> <li><code>GET /health</code> - Health check</li> </ul> <p>Code Structure:</p> <pre><code>domain-services-api/\n\u251c\u2500\u2500 main.py          # FastAPI app and routes\n\u251c\u2500\u2500 core.py          # Domain logic\n\u2514\u2500\u2500 Dockerfile       # Container definition\n</code></pre> <p>Authorization Pattern:</p> <p>Every operation calls authz-api:</p> <pre><code>authz_request = {\n    \"subject\": {\"id\": user_sub},\n    \"action\": {\"name\": \"create\"},\n    \"resource\": {\n        \"type\": \"workflow\",\n        \"id\": workflow_id\n    },\n    \"context\": {\"principal\": {\"id\": user_sub}}\n}\n\nresponse = requests.post(\n    f\"{AUTHZ_BASE_URL}/v1/evaluate\",\n    json=authz_request,\n    headers={\"Authorization\": f\"Bearer {token}\"}\n)\n\nif not response.json()[\"decision\"]:\n    raise HTTPException(status_code=403, detail=\"Forbidden\")\n</code></pre>"},{"location":"architecture/services/#4-flowpilot-ai-agent-api-port-8004","title":"4. flowpilot-ai-agent-api (Port 8004)","text":"<p>Role: Policy Enforcement Point (PEP) for AI Agent Execution</p> <p>Responsibilities:</p> <ul> <li>Executes workflow items on behalf of users</li> <li>Demonstrates agentic authorization patterns</li> <li>Service-to-service authentication using client credentials</li> <li>Calls authz-api before every execution</li> </ul> <p>Key Endpoints:</p> <ul> <li><code>POST /v1/execute</code> - Execute workflow item</li> <li><code>GET /health</code> - Health check</li> </ul> <p>Code Structure:</p> <pre><code>ai-agent-api/\n\u251c\u2500\u2500 main.py          # FastAPI app\n\u2514\u2500\u2500 Dockerfile       # Container definition\n</code></pre> <p>Service Account:</p> <ul> <li>Client ID: <code>flowpilot-agent</code></li> <li>Uses client credentials flow</li> <li>Acts as <code>agent-runner</code> with persona <code>ai-agent</code></li> </ul>"},{"location":"architecture/services/#5-opa-port-8181","title":"5. OPA (Port 8181)","text":"<p>Role: Policy Decision Point (PDP) for ABAC</p> <p>Responsibilities:</p> <ul> <li>Evaluates Rego policies</li> <li>Stateless decision engine</li> <li>Policies mounted from filesystem</li> <li>Hot-reload capability (restart recommended)</li> </ul> <p>Key Endpoints:</p> <ul> <li><code>POST /v1/data/auto_book/allow</code> - Evaluate auto-book policy</li> <li><code>GET /health</code> - Health check</li> <li><code>GET /v1/policies</code> - List loaded policies</li> </ul> <p>Policies:</p> <p>Located in <code>infra/opa/policies/</code>:</p> <ul> <li><code>auto_book.rego</code> - Autonomous booking policy</li> </ul> <p>Policy Structure:</p> <pre><code>package auto_book\n\ndefault allow = false\n\nallow {\n    # Policy conditions here\n}\n</code></pre> <p>Updating Policies:</p> <pre><code># Edit policy\nvim infra/opa/policies/auto_book.rego\n\n# Restart OPA to reload\ndocker compose restart opa\n</code></pre>"},{"location":"architecture/services/#6-firebase-authentication","title":"6. Firebase Authentication","text":"<p>Role: Identity Provider (IdP) - Fully managed by Google</p> <p>Responsibilities:</p> <ul> <li>Issues Firebase ID tokens (JWTs)</li> <li>Manages users and authentication</li> <li>Provides email/password authentication</li> <li>Supports multiple sign-in methods</li> <li>Automatic token refresh</li> <li>Built-in email verification and password reset</li> </ul> <p>Firebase Project: <code>vision-course-476214</code></p> <p>Authentication Methods:</p> <ol> <li>Email/Password - Primary method for users</li> <li>Built-in validation</li> <li>Password reset flows</li> <li> <p>Email verification</p> </li> <li> <p>Service Accounts - For service-to-service auth</p> </li> <li>Google Cloud identity tokens</li> <li>Automatic on Cloud Run</li> </ol> <p>Key Endpoints:</p> <ul> <li>Auth REST API: <code>https://identitytoolkit.googleapis.com/v1/</code></li> <li>Token verification: Firebase Admin SDK (no endpoint)</li> </ul> <p>User Data:</p> <ul> <li>Firebase Auth: Core identity (<code>uid</code>, <code>email</code>, <code>displayName</code>)</li> <li>Firestore: User profiles and preferences (<code>users</code> collection)</li> </ul>"},{"location":"architecture/services/#shared-libraries","title":"Shared Libraries","text":"<p>All services use shared libraries for common functionality:</p> <p>Location: <code>flowpilot-services/shared-libraries/</code></p> <p>Libraries:</p> <ol> <li>security.py - JWT validation, input sanitization, security headers</li> <li>api_logging.py - Structured API logging</li> <li>profile.py - User profile management</li> <li>utils.py - General utilities</li> </ol> <p>IMPORTANT: Shared libraries are copied into containers at build time. Changes require rebuilding all affected services:</p> <pre><code>docker compose up -d --build\n</code></pre>"},{"location":"architecture/services/#service-communication-flow","title":"Service Communication Flow","text":""},{"location":"architecture/services/#workflow-creation-flow","title":"Workflow Creation Flow","text":"<ol> <li>Client \u2192 domain-services-api: <code>POST /v1/workflows</code></li> <li>domain-services-api \u2192 authz-api: Validate authorization</li> <li>authz-api validates JWT: Using Firebase Admin SDK (local validation)</li> <li>authz-api \u2192 delegation-api: Check delegation (if needed)</li> <li>authz-api \u2192 OPA: Evaluate policy</li> <li>authz-api \u2192 domain-services-api: Return decision</li> <li>domain-services-api \u2192 delegation-api: Create delegation</li> <li>domain-services-api \u2192 Client: Return workflow</li> </ol>"},{"location":"architecture/services/#ai-agent-execution-flow","title":"AI Agent Execution Flow","text":"<ol> <li>ai-agent-api gets service token: Google Cloud identity token (automatic on Cloud Run)</li> <li>ai-agent-api \u2192 domain-services-api: Get workflow item details</li> <li>ai-agent-api \u2192 authz-api: Request authorization</li> <li>authz-api \u2192 delegation-api: Validate delegation chain</li> <li>authz-api \u2192 OPA: Evaluate auto-book policy</li> <li>authz-api \u2192 ai-agent-api: Return decision</li> <li>ai-agent-api: Execute or deny based on decision</li> </ol>"},{"location":"architecture/services/#api-documentation","title":"API Documentation","text":"<p>OpenAPI specifications are available in <code>flowpilot-openapi/</code>:</p> <ul> <li><code>authz.openapi.yaml</code> - Authorization API</li> <li><code>delegation.openapi.yaml</code> - Delegation API</li> <li><code>domain-services.openapi.yaml</code> - Workflow API</li> <li><code>ai-agent.openapi.yaml</code> - AI Agent API</li> <li><code>user-profile.openapi.yaml</code> - User Profile API</li> </ul> <p>View these specs using Swagger Editor, Postman, or the embedded Swagger UI in the documentation site.</p>"},{"location":"architecture/services/#container-platform","title":"Container Platform","text":"<p>All services are containerized using Docker:</p> <ul> <li>Base images: Python 3.11+ slim images</li> <li>Platform: Some services specify <code>linux/amd64</code> for compatibility</li> <li>Networking: Services communicate via Docker network</li> <li>Volumes: Persistent data stored in Docker volumes</li> </ul>"},{"location":"architecture/services/#development-workflow","title":"Development Workflow","text":""},{"location":"architecture/services/#rebuilding-a-service","title":"Rebuilding a Service","text":"<pre><code># Rebuild specific service\ndocker compose up -d --build flowpilot-authz-api\n\n# View logs\ndocker compose logs -f flowpilot-authz-api\n</code></pre>"},{"location":"architecture/services/#rebuilding-all-services","title":"Rebuilding All Services","text":"<pre><code># Rebuild everything\ndocker compose up -d --build\n</code></pre>"},{"location":"architecture/services/#testing-service-health","title":"Testing Service Health","text":"<pre><code># Test all health endpoints\nfor port in 8002 8003 8004 8005; do\n  curl -s http://localhost:$port/health | jq\ndone\n</code></pre>"},{"location":"architecture/services/#production-considerations","title":"Production Considerations","text":""},{"location":"architecture/services/#scalability","title":"Scalability","text":"<ul> <li>All services are stateless (except delegation-api SQLite)</li> <li>Can be horizontally scaled behind load balancers</li> <li>OPA is fully stateless and horizontally scalable</li> <li>Consider moving delegation-api to PostgreSQL for production</li> </ul>"},{"location":"architecture/services/#high-availability","title":"High Availability","text":"<ul> <li>Deploy multiple instances of each service</li> <li>Use managed OIDC provider (or HA Keycloak cluster)</li> <li>Use managed OPA deployment</li> <li>Implement circuit breakers for inter-service calls</li> </ul>"},{"location":"architecture/services/#monitoring","title":"Monitoring","text":"<ul> <li>All services expose <code>/health</code> endpoints</li> <li>Structured logging via <code>api_logging.py</code></li> <li>Consider adding:</li> <li>Prometheus metrics endpoints</li> <li>Distributed tracing (OpenTelemetry)</li> <li>Centralized logging (ELK, Splunk)</li> </ul>"},{"location":"architecture/services/#security","title":"Security","text":"<ul> <li>Use proper TLS certificates (not mkcert)</li> <li>Rotate secrets regularly</li> <li>Enable audit logging</li> <li>Set <code>INCLUDE_ERROR_DETAILS=0</code></li> <li>Use managed secret storage (e.g., GCP Secret Manager)</li> </ul>"},{"location":"contributing/code-of-conduct/","title":"Code of Conduct","text":"<p>We follow the Contributor Covenant Code of Conduct version 2.1: https://www.contributor-covenant.org/version/2/1/code_of_conduct/</p> <p>Report unacceptable behavior to: ciso@nura.pro</p>"},{"location":"contributing/contributing/","title":"Contributing","text":"<p>Thanks for your interest in improving 'Authorization using AuthZEN / OPA'.</p>"},{"location":"contributing/contributing/#development-setup","title":"Development setup","text":"<ul> <li>Python 3.10+</li> <li>uv recommended: https://docs.astral.sh/uv/</li> <li>pre-commit hooks</li> </ul> <pre><code>uv venv\nuv sync\npre-commit install\n</code></pre>"},{"location":"contributing/contributing/#workflow","title":"Workflow","text":"<ul> <li>Branch from <code>main</code>, name as <code>feat/...</code>, <code>fix/...</code>, or <code>docs/...</code></li> <li>Write tests for new behaviour</li> <li>Run <code>make format lint typecheck test</code></li> <li>Use conventional commits</li> <li>Open a pull request with a clear description</li> </ul>"},{"location":"contributing/contributing/#code-style","title":"Code style","text":"<ul> <li>Black + Ruff, PEP8</li> <li>mypy for typing</li> <li>Avoid nested functions; explicit names</li> <li>CLI entry points for components to ease testing</li> </ul>"},{"location":"contributing/contributing/#security","title":"Security","text":"<p>When contributin, ensure you are not (accidently) sharing secrets or real PII. See <code>SECURITY.md</code>.</p>"},{"location":"contributing/security/","title":"Security Policy","text":""},{"location":"contributing/security/#supported-versions","title":"Supported Versions","text":"Version Supported 1.0.x"},{"location":"contributing/security/#reporting-a-vulnerability","title":"Reporting a Vulnerability","text":"<p>We take the security of FlowPilot seriously. If you discover a security vulnerability, please follow these steps:</p>"},{"location":"contributing/security/#how-to-report","title":"How to Report","text":"<p>Please do NOT report security vulnerabilities through public GitHub issues.</p> <p>Instead, please report them via email to: ciso@nura.pro</p> <p>Include the following information: - Type of vulnerability - Full paths of source file(s) related to the vulnerability - Location of the affected source code (tag/branch/commit or direct URL) - Step-by-step instructions to reproduce the issue - Proof-of-concept or exploit code (if available) - Impact assessment (what an attacker could do)</p>"},{"location":"contributing/security/#response-timeline","title":"Response Timeline","text":"<ul> <li>Initial Response: Within 48 hours of report</li> <li>Status Update: Within 7 days with assessment and timeline</li> <li>Resolution: Security fixes will be prioritized based on severity</li> </ul>"},{"location":"contributing/security/#disclosure-policy","title":"Disclosure Policy","text":"<ul> <li>We follow responsible disclosure practices</li> <li>We will work with you to understand and resolve the issue</li> <li>We will credit you in the security advisory (unless you prefer to remain anonymous)</li> <li>We request that you do not publicly disclose the vulnerability until we have released a fix</li> </ul>"},{"location":"contributing/security/#security-best-practices","title":"Security Best Practices","text":"<p>When deploying FlowPilot in production:</p> <p>API endpoints</p> <ul> <li>Review sanitzation rules regularly</li> <li>Ensure application-level validation of JWT access tokens at all endpoints</li> </ul> <p>Authentication &amp; Authorization</p> <ul> <li>All API endpoints MUST require valid bearer tokens</li> <li>Use production-grade secrets (not demo credentials)</li> <li>Rotate credentials regularly</li> <li>Implement proper token validation and expiry</li> </ul> <p>Transport Security</p> <ul> <li>MUST use TLS 1.2 or higher for all services</li> <li>Use valid, public certificates</li> <li>Configure proper cipher suites</li> <li>Enable HSTS (HTTP Strict Transport Security)</li> </ul> <p>Network Security</p> <ul> <li>Deploy services behind a firewall</li> <li>Use network segmentation</li> <li>Limit service exposure (only expose necessary endpoints)</li> <li>Configure rate limiting</li> </ul> <p>Secrets Management</p> <ul> <li>Never commit secrets to version control</li> <li>Use environment variables or secret management systems</li> <li>Rotate IdP admin credentials immediately</li> <li>Generate new client secrets for all OIDC clients</li> </ul> <p>Database Security</p> <ul> <li>Encrypt data at rest</li> <li>Regular backups with encryption</li> <li>Limit database access to only necessary services</li> </ul> <p>Container Security</p> <ul> <li>Use minimal base images</li> <li>Scan images for vulnerabilities</li> <li>Run containers as non-root users</li> <li>Keep dependencies updated</li> <li>Use container registry scanning</li> </ul> <p>Privacy &amp; Compliance</p> <ul> <li>The authorization model is designed with privacy-by-design principles</li> <li>Do not requests scopes such as 'profile' for the access token</li> <li>Do not expose PII to the back-end ai-agent and domain-services APIs </li> <li>Do not store PII with domain-services data</li> </ul>"},{"location":"contributing/security/#security-features","title":"Security Features","text":"<p>FlowPilot implements several security best practices:</p> <p>Authorization Architecture</p> <ul> <li>Centralized policy decision point (PDP)</li> <li>Policy enforcement points (PEP) at domain service boundaries</li> <li>Relationship-based access control (ReBAC) for delegation</li> <li>Explicit authorization checks for every operation</li> </ul> <p>Authentication</p> <ul> <li>OIDC with PKCE for desktop client</li> <li>Bearer token authentication for service-to-service communication</li> <li>Keycloak as identity provider with realm isolation</li> </ul> <p>Privacy by Design</p> <ul> <li>No PII exposed to AI/LLM components</li> <li>Principal identity uses opaque identifiers (sub)</li> <li>Profile information separated from domain data</li> <li>Progressive profiling without storing sensitive data</li> </ul> <p>Auditability</p> <ul> <li>All authorization decisions are logged</li> <li>Per-item execution results with reasons</li> <li>Delegation chains are explicit and verifiable</li> </ul>"},{"location":"contributing/security/#dependencies","title":"Dependencies","text":"<p>We recommend: - Regularly updating dependencies - Monitoring security advisories for:   - Python packages (imported libraries are documented in requirements.txt)   - Docker base images</p>"},{"location":"contributing/security/#security-contacts","title":"Security Contacts","text":"<p>For security-related questions or concerns: - Email: ciso@nura.pro - Response time: Within 48 hours</p> <p>Last updated: 2026-01-15</p>"},{"location":"deployment/environment/","title":"Environment","text":"<p>Documentation coming soon.</p>"},{"location":"deployment/gcp/","title":"Gcp","text":"<p>Documentation coming soon.</p>"},{"location":"deployment/local/","title":"Local","text":"<p>Documentation coming soon.</p>"},{"location":"deployment/overview/","title":"Self-Hosting Overview","text":"<p>FlowPilot is offered as a managed service, but you can also self-host your own instance.</p>"},{"location":"deployment/overview/#why-self-host","title":"Why Self-Host?","text":"<p>Consider self-hosting if you:</p> <ul> <li>Need full control over infrastructure</li> <li>Have strict data residency requirements</li> <li>Want to customize policies beyond what the managed service offers</li> <li>Are building a white-label solution</li> </ul>"},{"location":"deployment/overview/#deployment-options","title":"Deployment Options","text":"<ul> <li>Local Development: Docker Compose for testing and development</li> <li>GCP Cloud Run: Production-ready deployment on Google Cloud</li> <li>Custom: Deploy to any Kubernetes cluster or cloud provider</li> </ul>"},{"location":"deployment/overview/#prerequisites","title":"Prerequisites","text":"<p>Self-hosting requires:</p> <ul> <li>Infrastructure expertise (Docker, cloud platforms)</li> <li>Security expertise (JWT validation, TLS, secrets management)</li> <li>Policy authoring expertise (Rego/OPA)</li> </ul>"},{"location":"deployment/overview/#next-steps","title":"Next Steps","text":"<p>For most developers, we recommend using the managed service at the production endpoints listed in the Integration Guide.</p> <p>If you still want to self-host, see: - GCP Cloud Run - Production deployment - Local Development - Docker Compose setup</p>"},{"location":"development/about-authzen/","title":"Policy Orchestration","text":"<p>Policy evaluation requires structured, policy-relevant information. In FlowPilot, this information is exchanged with the policy engine using AuthZEN.</p> <p>The authz-api acts as the orchestration layer between Policy Enforcement Points (PEPs) and the Policy Decision Point (PDP). It receives AuthZEN requests from PEPs and produces enriched, normalized AuthZEN input for the PDP.</p> <p>To achieve this, the authz-api performs the following steps:</p> <ol> <li>Validate JWTs \u2013 Ensures bearer access tokens are valid and trustworthy</li> <li>Resolve Delegation \u2013 Queries the delegation API to obtain ReBAC relationships</li> <li>Enrich Context \u2013 Adds policy-relevant attributes such as consent flags and thresholds</li> <li>Normalize Data \u2013 Coerces types and formats (for example, RFC 3339 timestamps, numeric values)</li> <li>Invoke OPA \u2013 Submits the enriched input to the policy engine</li> <li>Return Decision \u2013 Produces a structured allow/deny decision with reason codes</li> </ol> <p>Key insight: PEPs submit intent, while the PDP receives decision-ready facts. The authz-api explicitly bridges this gap, ensuring that policies are evaluated against complete and consistent context rather than raw application requests.</p>"},{"location":"development/about-authzen/#authzen-as-an-interface-contract","title":"AuthZEN as an Interface Contract","text":"<p>AuthZEN defines a standardized interface between PEPs and PDPs, focusing on how authorization context is exchanged, not how policy is implemented.</p> <p>Rather than prescribing a policy language or decision logic, AuthZEN standardizes: - the structure of authorization requests and responses - the separation of subject, action, resource, and context - the contract between enforcement and decision components</p> <p>In FlowPilot, AuthZEN serves as a stable integration boundary: - PEPs remain agnostic of the underlying policy engine - the PDP (OPA) is shielded from application-specific variability - the authorization architecture can evolve without breaking callers</p> <p>AuthZEN is not a formal international standard, but it provides a well-defined and interoperable contract that aligns with modern zero-trust and policy-as-code architectures.</p>"},{"location":"development/about-authzen/#manifest-structure","title":"Manifest Structure","text":"<p>The manifest has an <code>attributes</code> section that in addition to custom persona attributes, also defines the corresponding properties of a workflow item (the <code>properties</code> of a <code>resource</code>) in the AuthZEN document.</p> <p>Their values are coerced automatically by the authz-api to the type specified. Their values are also defaulted in case they are optional and a default value is provided. A default value of <code>null</code> means that the attribute will only be created when it explicitly has a value. </p> <pre><code>attributes:\n  # Persona custom attributes\n  # ...\n\n  # Resource attributes (from workflow/item properties)\n  - name: planned_price\n    type: float\n    source: resource\n    default: 0.0\n    required: false\n    description: \"Planned cost of the trip\"\n\n  - name: departure_date\n    type: date\n    source: resource\n    default: null\n    required: true\n    description: \"Trip departure date (ISO 8601 format)\"\n\n  - name: airline_risk_score\n    type: float\n    source: resource\n    default: null\n    required: false\n    description: \"Airline risk score (1.0=lowest risk, 5.0=highest risk). Only present for flight items.\"\n</code></pre>"},{"location":"development/about-authzen/#authzen-examples","title":"AuthZEN Examples","text":"<p>This is an example of an AuthZEN document sent as payload by the PEP to the authz-api (as PIP orchestrator for the PDP):</p> <pre><code>  \"request_body\": {\n    \"subject\": {\n      \"type\": \"agent\",\n      \"id\": \"domain-services-api\",\n      \"properties\": {\n        \"persona\": \"ai-agent\"\n      }\n    },\n    \"action\": {\n      \"name\": \"execute\"\n    },\n    \"resource\": {\n      \"type\": \"workflow_item\",\n      \"id\": \"i_31ea5dc0\",\n      \"properties\": {\n        \"domain\": \"flowpilot\",\n        \"workflow_id\": \"w_0f7411ba\",\n        \"workflow_item_id\": \"i_31ea5dc0\",\n        \"workflow_item_kind\": \"transport\",\n        \"planned_price\": 4000.0,\n        \"departure_date\": \"2026-02-01T00:00:00Z\",\n        \"airline_risk_score\": 2.0,\n        \"owner\": {\n          \"type\": \"user\",\n          \"id\": \"d91fb602-29f2-43d0-8878-4d646f442967\",\n        }\n      }\n    },\n    \"context\": {\n      \"policy_hint\": \"travel\",\n      \"principal\": {\n        \"type\": \"user\",\n        \"id\": \"89eb5366-bab3-46e4-b8e1-abc5f2ea4631\",\n        \"persona\": \"travel-agent\"\n      }\n    }\n  }\n</code></pre> <p>Here's the corresponding enriched AuthZEN payload that the authz-api sends to OPA:</p> <pre><code>{\n  \"type\": \"api_request\",\n  \"timestamp\": \"2026-01-06T13:14:01.042085+00:00\",\n  \"method\": \"POST\",\n  \"path\": \"OPA /v1/data/auto_book/allow\",\n  \"request_body\": {\n    \"subject\": {\n      \"type\": \"agent\",\n      \"id\": \"c08d6b1a-10bd-4a02-9d5b-a28a0ff3bc53\",\n      \"persona\": \"ai-agent\"\n    },\n    \"action\": {\n      \"name\": \"execute\"\n    },\n    \"resource\": {\n      \"type\": \"workflow_item\",\n      \"id\": \"i_31ea5dc0\",\n      \"properties\": {\n        \"domain\": \"flowpilot\",\n        \"workflow_id\": \"w_0f7411ba\",\n        \"workflow_item_id\": \"i_31ea5dc0\",\n        \"workflow_item_kind\": \"transport\",\n        \"planned_price\": 4000.0,\n        \"departure_date\": \"2026-02-01T00:00:00Z\",\n        \"airline_risk_score\": 2.0,\n        \"owner\": {\n          \"type\": \"user\",\n          \"id\": \"d91fb602-29f2-43d0-8878-4d646f442967\",\n          \"persona\": \"traveler\",\n          \"persona_id\": \"b9678f30-f4b0-4033-82db-846357311165\",\n          \"persona_status\": \"active\",\n          \"persona_valid_from\": \"2024-01-01T00:00:00Z\",\n          \"persona_valid_till\": \"2026-12-31T23:59:59Z\",\n          \"autobook_consent\": true,\n          \"autobook_price\": 10000,\n          \"autobook_leadtime\": 7,\n          \"autobook_risklevel\": 5\n        }\n      }\n    },\n    \"context\": {\n      \"principal\": {\n        \"type\": \"user\",\n        \"id\": \"89eb5366-bab3-46e4-b8e1-abc5f2ea4631\",\n        \"persona\": \"travel-agent\"\n      },\n      \"delegation\": {\n        \"valid\": true,\n        \"delegation_chain\": [\n          \"d91fb602-29f2-43d0-8878-4d646f442967\",\n          \"30dc31a0-2061-43c7-aa2a-7f7760936fc9\",\n          \"89eb5366-bab3-46e4-b8e1-abc5f2ea4631\"\n        ],\n        \"delegated_actions\": [\n          \"execute\"\n        ]\n      }\n    }\n  }\n}\n</code></pre>"},{"location":"development/about-authzen/#the-role-of-authz-api","title":"The role of Authz-API","text":""},{"location":"development/about-authzen/#authz-api","title":"AuthZ-API","text":"<p>Purpose: Fetches persona data for authorization decisions (acts as Policy Information Point)</p> <p>Persona Fetching Logic:</p> <ol> <li>Extract <code>owner.id</code> and <code>owner.persona</code> (title) from AuthZEN request</li> <li>If <code>owner.persona_id</code> is present, fetch directly: <code>GET /v1/personas/{persona_id}</code></li> <li>If only <code>owner.persona</code> (title) is present, fetch by user and title: <code>GET /v1/users/{user_sub}/personas</code></li> <li>If fetch fails (404, 403, timeout), use default values (deny by default)</li> <li>Augment <code>resource.properties.owner</code> with autobook attributes for OPA</li> </ol> <p>Code Location: <code>flowpilot-services/authz-api/authz_core.py</code></p> <p>Persona data flows into OPA as part of the <code>resource.properties.owner</code> and <code>context.principal</code> objects.</p> <p>OPA policies use these attributes to evaluate authorization gates:</p> <pre><code># Consent check\nhas_consent if {\n  input.resource.properties.owner.autobook_consent == true\n}\n\n# Cost gate\nwithin_cost_limit if {\n  planned_price := input.resource.properties.planned_price\n  max_cost := input.resource.properties.owner.autobook_price\n  planned_price &lt;= max_cost\n}\n\n# Persona status check\nowner_persona_active if {\n  input.resource.properties.owner.persona_status == \"active\"\n}\n\n# Persona temporal validity\nowner_persona_valid_time if {\n  valid_from_str := input.resource.properties.owner.persona_valid_from\n  valid_till_str := input.resource.properties.owner.persona_valid_till\n  valid_from := time.parse_rfc3339_ns(valid_from_str)\n  valid_till := time.parse_rfc3339_ns(valid_till_str)\n  now := time.now_ns()\n  now &gt;= valid_from\n  now &lt;= valid_till\n}\n</code></pre>"},{"location":"development/about-authzen/#data-sources-for-opa-input","title":"Data Sources for OPA Input","text":"Field Source Provider <code>subject.id</code> AuthZEN request PEP <code>subject.properties.persona</code> JWT custom claims Authz-API <code>action.name</code> AuthZEN request PEP <code>resource.id</code> AuthZEN request PEP <code>resource.properties.planned_price</code> Workflow item data PEP <code>resource.properties.departure_date</code> Workflow item data PEP (normalized by authz-api) <code>resource.properties.owner.persona</code> Workflow creation PEP <code>resource.properties.owner.persona_id</code> Persona lookup User-Profile-API (via authz-api) <code>resource.properties.owner.persona_status</code> Persona lookup User-Profile-API (via authz-api) <code>resource.properties.owner.persona_valid_from</code> Persona lookup User-Profile-API (via authz-api) <code>resource.properties.owner.persona_valid_till</code> Persona lookup User-Profile-API (via authz-api) <code>resource.properties.owner.autobook_*</code> Persona lookup User-Profile-API (via authz-api) <code>context.delegation.*</code> Delegation graph Delegation-API (via authz-api) <code>context.principal</code> AuthZEN request or JWT PEP / Authz-API"},{"location":"development/about-authzen/#related-documentation","title":"Related Documentation","text":"<ul> <li>API Reference: Authz API - Full API specification</li> <li>Policy Development Guide - How OPA policies use persona data</li> <li>Persona Development Guide - How personas are managed</li> <li>Authorization Architecture - Overall authorization flow</li> <li>Authentication Architecture - Overall access token flow</li> </ul>"},{"location":"development/authorization-scenarios/","title":"Policy Testing","text":"<p>The regression suite is not just testing \u201caccess allowed vs denied\u201d. It systematically demonstrates how FlowPilot\u2019s authorization model behaves under real-world conditions: consent, personas, constraints, delegation chains, revocation, scope changes, and temporal validity.</p> <p>At a high level, FlowPilot evaluates every action along four axes:</p> <ul> <li>Who is acting (principal)</li> <li>In which persona they are acting</li> <li>Under which delegation or invitation</li> <li>Against which policy constraints, both at workflow and item level</li> </ul> <p>What follows is a human-readable explanation of what the tests prove.</p>"},{"location":"development/authorization-scenarios/#1-fail-fast-authorization-at-the-right-level","title":"1. Fail-Fast Authorization at the right level","text":"<p>FlowPilot distinguishes between workflow-level authorization and item-level authorization. Only when workflow-level checks pass does FlowPilot evaluate item-level constraints.</p> <p>This is visible throughout the tests:</p> <ul> <li>Users without consent are denied immediately.</li> <li>Users with read-only delegation are denied immediately on execute.</li> <li>Persona mismatches are rejected before any item logic runs.</li> </ul> <p>This fail-fast behavior is intentional: it prevents partial execution and avoids leaking information about items the principal should not even see.</p>"},{"location":"development/authorization-scenarios/#2-consent-is-a-first-class-policy-primitive","title":"2. Consent is a first-class Policy Primitive","text":"<p>Consent is not implied by ownership, delegation, or persona.</p> <ul> <li>A user with no autobook consent is denied even if everything else appears correct.</li> <li>Consent is evaluated before cost limits, airline risk, or other business rules.</li> </ul> <p>This ensures that automation is never triggered implicitly or accidentally, even by trusted delegates.</p>"},{"location":"development/authorization-scenarios/#3-persona-is-not-cosmetic-it-is-enforced","title":"3. Persona is not cosmetic \u2014 it is Enforced","text":"<p>Personas in FlowPilot are authoritative execution contexts, not labels.</p> <p>The tests demonstrate that:</p> <ul> <li>A workflow is bound to a specific persona type.</li> <li>Executing with a different persona \u2014 even by the owner \u2014 is denied.</li> <li>Delegates must explicitly select a delegation persona, not an invitation persona.</li> <li>Switching persona mid-flow immediately changes what actions are permitted.</li> </ul> <p>In practice, this means:</p> <ul> <li>\u201cWho you are\u201d is less important than \u201cwho you are acting as.\u201d</li> <li>Owners cannot bypass constraints by switching personas.</li> <li>Delegates cannot escalate privileges by selecting the wrong persona.</li> </ul>"},{"location":"development/authorization-scenarios/#4-delegation-is-explicit-scoped-and-revocable","title":"4. Delegation is Explicit, Scoped, and Revocable","text":"<p>Delegation in FlowPilot is:</p> <ul> <li>Explicit (must be created)</li> <li>Scoped (read vs execute)</li> <li>Persona-aware</li> <li>Revocable, with immediate effect</li> </ul> <p>The tests show that:</p> <ul> <li>Changing delegation scope requires revoke + recreate, avoiding ambiguous state.</li> <li>Read-only delegates can view but never execute.</li> <li>Revoking an intermediate delegation breaks the entire transitive chain.</li> <li>Restoring delegation restores access predictably.</li> </ul> <p>This makes delegation auditable, deterministic, and safe to reason about.</p>"},{"location":"development/authorization-scenarios/#5-transitive-delegation-works-and-stops-where-it-should","title":"5. Transitive Delegation works \u2014 and stops where it should","text":"<p>FlowPilot supports multi-hop delegation:</p> <ul> <li>Owner \u2192 Delegate \u2192 Sub-delegate \u2192 \u2026</li> </ul> <p>As long as:</p> <ul> <li>Each hop has valid scope</li> <li>Personas are compatible</li> <li>No delegation in the chain is revoked</li> </ul> <p>Once a single link is revoked or downgraded:</p> <ul> <li>Access is immediately denied downstream</li> <li>There is no partial or cached privilege</li> </ul> <p>This enables realistic enterprise scenarios (assistants, agencies, back-office chains) without losing control.</p>"},{"location":"development/authorization-scenarios/#6-item-level-constraints-are-applied-only-when-appropriate","title":"6. Item-Level Constraints are applied only when appropriate","text":"<p>Once workflow-level authorization succeeds, FlowPilot applies fine-grained item policies, such as:</p> <ul> <li>Cost ceilings</li> <li>Risk thresholds</li> <li>Time-based constraints (e.g. minimum advance notice)</li> </ul> <p>The tests demonstrate mixed outcomes:</p> <ul> <li>Some items allowed</li> <li>Some denied with precise reason codes</li> <li>No errors or undefined behavior</li> </ul> <p>This shows that FlowPilot can safely combine coarse authorization with fine-grained business rules in a single execution.</p>"},{"location":"development/authorization-scenarios/#7-time-and-status-matter","title":"7. Time and Status matter","text":"<p>Personas and delegations are not static:</p> <ul> <li>Personas can be inactive, suspended, or not yet valid.</li> <li>Delegations can expire or be revoked.</li> </ul> <p>The tests confirm that:</p> <ul> <li>Personas not yet valid cannot be used to create or execute workflows.</li> <li>Inactive personas immediately invalidate access.</li> <li>Temporal validity is enforced consistently at creation and execution time.</li> </ul> <p>This is critical for compliance, onboarding/offboarding, and regulated environments.</p>"},{"location":"development/authorization-scenarios/#8-crudx-is-persona-bound-not-role-assumed","title":"8. CRUDX is Persona-Bound, not Role-Assumed","text":"<p>Allowed actions are defined per persona, not per user.</p> <p>The tests show that:</p> <ul> <li>Visitor personas can read but not update or execute.</li> <li>Office-manager personas cannot execute autobook workflows.</li> <li>Even with delegation, actions outside a persona\u2019s allowed-actions are denied.</li> </ul> <p>This avoids \u201crole explosion\u201d and keeps authorization declarative and predictable.</p>"},{"location":"development/authorization-scenarios/#9-known-limitations-are-explicit-and-test-covered","title":"9. Known limitations are explicit and test-Covered","text":"<p>One test intentionally documents a known limitation: - Persona type is not yet enforced for read access under invitation.</p> <p>This is valuable because:</p> <ul> <li>The behavior is explicit, not accidental</li> <li>The test suite already captures the expected future behavior</li> <li>Policy evolution can be regression-tested safely</li> </ul>"},{"location":"development/authorization-scenarios/#what-this-dmonstrates-overall","title":"What this dmonstrates overall","text":"<p>Taken together, these tests demonstrate that FlowPilot provides:</p> <ul> <li>Deterministic authorization</li> <li>Strong separation between consent, delegation, persona, and policy</li> <li>Safe transitive delegation</li> <li>Immediate revocation effects</li> <li>Fail-fast behavior where it matters</li> <li>Fine-grained item control without leaking privilege</li> </ul> <p>In short: authorization is no longer implicit, role-based, or context-blind \u2014 it is explicit, composable, and explainable.</p>"},{"location":"development/delegations/","title":"Persona Based Delegation","text":"<p>This guide explains FlowPilot's delegation model, including the data model, API operations, authorization rules, and technical implementation details.</p>"},{"location":"development/delegations/#overview","title":"Overview","text":"<p>A delegation represents an explicit authorization relationship where a principal (resource owner) grants a delegate (user or agent) permission to act on their behalf within a specific context. Delegations are the core mechanism for implementing relationship-based access control (ReBAC) in FlowPilot's authorization model.</p> <p>Delegations answer the fundamental authorization question: \"Is subject X allowed to act on behalf of principal Y in this context?\"</p> <p>Rather than requiring direct ownership for every action, FlowPilot evaluates delegation chains to determine whether a delegate has been granted authority to perform actions on resources owned by another user.</p>"},{"location":"development/delegations/#key-concepts","title":"Key Concepts","text":"<ul> <li>Delegations are directional: principal \u2192 delegate</li> <li>Delegations may be workflow-scoped (apply only to a specific workflow) or unscoped (apply to all workflows owned by the principal)</li> <li>Delegations have explicit scope (list of permitted actions: <code>read</code>, <code>execute</code>, etc.)</li> <li>Delegations have explicit lifecycle:</li> <li>temporal validity (<code>expires_at</code>)</li> <li>revocation status (<code>revoked_at</code>)</li> <li>Delegations support transitive chains (A \u2192 B \u2192 C) with configurable depth limits</li> <li>Delegations are fail-closed: if no delegation path with required permissions exists, authorization fails</li> <li>Delegations are explicitly granted: there are no implicit or inherited delegations</li> </ul>"},{"location":"development/delegations/#why-delegations-matter","title":"Why Delegations Matter","text":"<p>Introducing delegations as a first-class authorization primitive enables several critical architectural properties:</p>"},{"location":"development/delegations/#1-user-managed-access-uma","title":"1. User-Managed Access (UMA)","text":"<p>Users control access to their own resources without requiring centralized administration:</p> <ul> <li>Resource owners explicitly grant and revoke delegations</li> <li>Delegation decisions are made closest to the source of authority</li> <li>No central administrator is required to manage who can act for whom</li> <li>Users maintain direct control over their authorization boundaries</li> </ul>"},{"location":"development/delegations/#2-separation-of-concerns-rebac-vs-abac","title":"2. Separation of Concerns (ReBAC vs ABAC)","text":"<p>Delegation provides a clean separation between relationship-based and attribute-based authorization:</p> <ul> <li>ReBAC (Delegation): Answers \"Can this delegate act for this principal?\"</li> <li>ABAC (Policy): Answers \"Should this action be allowed based on attributes?\"</li> </ul> <p>This separation ensures: - Relationship validation happens before policy evaluation - Policy logic remains business-focused, not relationship-focused - Clear failure reasons: delegation failure vs policy denial</p>"},{"location":"development/delegations/#3-transitive-authority","title":"3. Transitive Authority","text":"<p>Delegation chains enable realistic organizational scenarios:</p> <ul> <li>A user delegates to their assistant</li> <li>The assistant can sub-delegate (within granted scope) to other agents</li> <li>The entire chain is validated and auditable</li> <li>Depth limits prevent privilege amplification and unbounded traversal</li> </ul>"},{"location":"development/delegations/#4-explainable-authorization","title":"4. Explainable Authorization","text":"<p>Delegation chains provide transparency:</p> <ul> <li>Every authorization decision includes the delegation chain (if any)</li> <li>Users can see exactly who acted on their behalf</li> <li>Audit trails capture the complete delegation path</li> <li>Debugging authorization failures is straightforward</li> </ul>"},{"location":"development/delegations/#architectural-impact","title":"Architectural Impact","text":"<p>FlowPilot delegations integrate seamlessly with personas and policies:</p> <ul> <li>Personas define what a user can do in a given role</li> <li>Delegations define who can act on someone's behalf</li> <li>Policies define when those actions should be allowed</li> </ul> <p>Together, they provide: - RBAC-like clarity through persona-based roles - ReBAC-like flexibility through delegation relationships - ABAC-like expressiveness through policy evaluation</p> <p>At the same time, delegation-based authorization eliminates common access management antipatterns:</p> <ul> <li>No shared accounts or credentials</li> <li>No overprivileged service accounts</li> <li>No static permission assignment bottlenecks</li> <li>No implicit trust relationships</li> </ul> <p>Instead, authorization becomes: - explicit (delegations must be granted) - decentralized (users manage their own delegations) - auditable (delegation chains are tracked) - time-bound (delegations expire) - revocable (delegations can be revoked)</p> <p>In FlowPilot, delegations place users at the center of access control, giving them explicit control over who can act on their behalf and for how long.</p>"},{"location":"development/delegations/#delegation-data-model","title":"Delegation Data Model","text":""},{"location":"development/delegations/#core-attributes","title":"Core Attributes","text":"Field Type Description <code>id</code> Integer Unique database identifier for the delegation <code>principal_id</code> String Owner's user ID (who is delegating authority) <code>delegate_id</code> String Delegate's user ID or agent identifier (who receives authority) <code>workflow_id</code> String (optional) Specific workflow ID to scope delegation (null = all workflows) <code>scope</code> Array[String] List of permitted actions (e.g., <code>[\"read\"]</code>, <code>[\"read\", \"execute\"]</code>) <code>expires_at</code> ISO 8601 Timestamp when delegation expires <code>created_at</code> ISO 8601 Creation timestamp <code>revoked_at</code> ISO 8601 (optional) Revocation timestamp (null = active)"},{"location":"development/delegations/#delegation-scopes","title":"Delegation Scopes","text":"<p>Delegations include an explicit <code>scope</code> field that defines which actions the delegate may perform:</p> Action Description <code>read</code> Delegate can view/read resources <code>update</code> Delegate can modify/update resources <code>execute</code> Delegate can execute actions (e.g., book travel, run workflows) <code>delete</code> Delegate can delete resources <p>Scope Rules: - Default scope (when not specified): <code>[\"execute\"]</code> - Scope is always an array (supports multiple actions) - Subdelegations cannot grant more permissions than the delegator has - Action restrictions apply throughout the entire delegation chain - Available actions are configured via <code>DELEGATION_ALLOWED_ACTIONS</code> environment variable</p> <p>Important: The <code>scope</code> field defines what actions are permitted by the delegation relationship. Final authorization still requires policy (OPA) approval.</p>"},{"location":"development/delegations/#delegation-states","title":"Delegation States","text":"<p>A delegation path exists and grants permissions for an action if: - A delegation chain exists from owner to delegate - All delegations in the chain have <code>revoked_at</code> = <code>NULL</code> (not revoked) - All delegations in the chain have <code>expires_at</code> in the future (not expired) - All delegations match the requested workflow scope (if workflow-scoped) - The chain is within the configured hop limit (max_depth) - The requested action is in the intersection of all <code>scope</code> arrays in the chain</p>"},{"location":"development/delegations/#example-delegation-document","title":"Example Delegation Document","text":"<pre><code>{\n  \"id\": 42,\n  \"principal_id\": \"carlo-uuid-1234\",\n  \"delegate_id\": \"yannick-uuid-5678\",\n  \"workflow_id\": \"workflow-abc-123\",\n  \"scope\": [\"read\", \"execute\"],\n  \"expires_at\": \"2026-01-23T15:30:00Z\",\n  \"created_at\": \"2026-01-16T10:00:00Z\",\n  \"revoked_at\": null\n}\n</code></pre> <p>This delegation grants Yannick the ability to read and execute actions on Carlo's workflow <code>workflow-abc-123</code> until January 23, 2026.</p>"},{"location":"development/delegations/#delegation-lifecycle","title":"Delegation Lifecycle","text":""},{"location":"development/delegations/#delegation-api","title":"Delegation-API","text":"<p>Purpose: Delegation relationship management and validation</p> <p>Endpoints:</p> <ul> <li><code>POST /v1/delegations</code> - Create delegation (fails with HTTP 400 if duplicate exists)</li> <li><code>GET /v1/delegations</code> - List delegations (by principal_id or delegate_id)</li> <li><code>DELETE /v1/delegations</code> - Revoke delegation</li> <li><code>GET /v1/delegations/validate</code> - Validate delegation chain</li> </ul> <p>Authorization:</p> <ul> <li>All endpoints require JWT authentication</li> <li>Delegation creation validates subdelegation permissions</li> <li>Service accounts (persona=service) can create delegations on behalf of owners</li> </ul> <p>Code Location: <code>flowpilot-services/delegation-api/</code></p> <p>Validation Rules:</p> <ul> <li><code>principal_id</code> \u2260 <code>delegate_id</code> (cannot delegate to yourself)</li> <li><code>expires_in_days</code> must be between <code>DELEGATION_MIN_EXPIRY_DAYS</code> (1) and <code>DELEGATION_MAX_EXPIRY_DAYS</code> (365)</li> <li><code>scope</code> must only contain allowed actions defined in <code>DELEGATION_ALLOWED_ACTIONS</code> environment variable</li> <li>Subdelegations require valid parent delegation with sufficient scope</li> </ul>"},{"location":"development/delegations/#create","title":"Create","text":"<p>Delegations are created via the delegation-api POST /v1/delegations endpoint.</p> <p>Request: <pre><code>POST /v1/delegations\nAuthorization: Bearer &lt;user-token&gt;\nContent-Type: application/json\n\n{\n  \"principal_id\": \"carlo-uuid-1234\",\n  \"delegate_id\": \"yannick-uuid-5678\",\n  \"workflow_id\": \"workflow-abc-123\",\n  \"scope\": [\"read\", \"execute\"],\n  \"expires_in_days\": 7\n}\n</code></pre></p> <p>Response: <pre><code>{\n  \"principal_id\": \"carlo-uuid-1234\",\n  \"delegate_id\": \"yannick-uuid-5678\",\n  \"workflow_id\": \"workflow-abc-123\",\n  \"scope\": [\"read\", \"execute\"],\n  \"expires_at\": \"2026-01-23T15:30:00Z\",\n  \"created_at\": \"2026-01-16T10:00:00Z\",\n  \"revoked_at\": null\n}\n</code></pre></p> <p>Authorization:  - User must be authenticated - For owner delegations: JWT <code>sub</code> must match <code>principal_id</code> - For subdelegations: Delegator must have sufficient permissions to delegate</p> <p>Uniqueness Enforcement: The database enforces a unique constraint on <code>(principal_id, delegate_id, workflow_id, scope)</code>. This scope-aware uniqueness allows multiple delegation types to coexist between the same two users. For example:</p> <ul> <li>Carlo \u2192 Yannick with scope <code>[\"read\"]</code> (invite relationship)</li> <li>Carlo \u2192 Yannick with scope <code>[\"read\", \"execute\"]</code> (delegate relationship)</li> </ul> <p>These are treated as distinct delegation relationships because they have different scopes, even though they connect the same principal and delegate.</p> <p>Attempting to create a duplicate delegation (same principal, delegate, workflow, AND scope) raises a <code>ValueError</code> with HTTP 400 and a detailed error message: <pre><code>Delegation from 'carlo-uuid' to 'yannick-uuid' for workflow 'workflow-123' with scope [\"read\", \"execute\"] already exists \n(expires: 2026-01-23T15:30:00Z). \nTo modify the delegation, first revoke it using DELETE /v1/delegations, then create a new one. \nOr consider if the existing delegation already meets your needs.\n</code></pre></p> <p>Idempotency Handling:</p> <p>The API is NOT idempotent by design. Duplicate creation attempts fail explicitly to: - Prevent accidental expiry modifications without explicit revocation - Ensure callers understand existing delegation state - Maintain clear audit trail of delegation lifecycle (create \u2192 revoke \u2192 recreate)</p> <p>For idempotent provisioning, scripts should implement their own logic by checking for existence first (GET /v1/delegations) or catching the 400 error and validating that the existing delegation meets requirements.</p> <p>Design Rationale:</p> <p>Treating delegations with different scopes as distinct relationships enables important use cases:</p> <ul> <li> <p>Invite vs Delegate: An \"invite\" (read-only access) is fundamentally different from a \"delegate\" (read+execute authority)</p> </li> <li> <p>Different Lifecycles: Invites and delegations may have different expiration periods and revocation policies</p> </li> <li> <p>Granular Control: Users can independently manage read-only sharing and execution delegation</p> </li> </ul> <p>Automatic Delegation Creation:</p> <p>When workflows are created via domain-services-api, the system automatically creates a delegation to the <code>agent-runner</code> service account:</p> <pre><code># Auto-created delegation for AI agent execution\ndelegation_response = requests.post(\n    f\"{DELEGATION_API_BASE_URL}/v1/delegations\",\n    json={\n        \"principal_id\": owner_sub,\n        \"delegate_id\": \"agent-runner\",\n        \"workflow_id\": workflow_id,\n        \"scope\": [\"execute\"],\n        \"expires_in_days\": 30,\n    },\n    headers={\"Authorization\": f\"Bearer {service_token}\"}\n)\n</code></pre> <p>This enables AI agents to execute workflows autonomously (if consent is granted).</p> <p>Note: The domain-services-api handles duplicate delegation errors gracefully by catching the HTTP 400 response and logging it, allowing workflow creation to succeed even if the agent delegation already exists from a previous workflow.</p>"},{"location":"development/delegations/#list","title":"List","text":"<p>Users can list delegations they've granted (outgoing) or received (incoming):</p> <p>Outgoing delegations (principal_id): <pre><code>GET /v1/delegations?principal_id=carlo-uuid\nAuthorization: Bearer &lt;user-token&gt;\n</code></pre></p> <p>Incoming delegations (delegate_id): <pre><code>GET /v1/delegations?delegate_id=yannick-uuid\nAuthorization: Bearer &lt;user-token&gt;\n</code></pre></p> <p>Optional query parameters: - <code>workflow_id</code>: Filter by specific workflow - <code>include_expired</code>: Include expired delegations (default: false)</p> <p>Response: <pre><code>{\n  \"delegations\": [\n    {\n      \"principal_id\": \"carlo-uuid-1234\",\n      \"delegate_id\": \"yannick-uuid-5678\",\n      \"workflow_id\": \"workflow-abc-123\",\n      \"scope\": [\"read\", \"execute\"],\n      \"expires_at\": \"2026-01-23T15:30:00Z\",\n      \"created_at\": \"2026-01-16T10:00:00Z\",\n      \"revoked_at\": null\n    }\n  ]\n}\n</code></pre></p>"},{"location":"development/delegations/#validate","title":"Validate","text":"<p>Validate whether a delegation chain exists and determine which actions are available:</p> <pre><code>GET /v1/delegations/validate?principal_id=carlo-uuid&amp;delegate_id=yannick-uuid&amp;workflow_id=workflow-123\nAuthorization: Bearer &lt;service-token&gt;\n</code></pre> <p>Response (delegation exists): <pre><code>{\n  \"delegation_chain\": [\"carlo-uuid-1234\", \"yannick-uuid-5678\"],\n  \"delegated_actions\": [\"read\", \"execute\"]\n}\n</code></pre></p> <p>Response (no delegation): <pre><code>{\n  \"delegation_chain\": [],\n  \"delegated_actions\": []\n}\n</code></pre></p> <p>Interpretation: - If <code>delegated_actions</code> is non-empty, a valid delegation path exists with those permissions - If <code>delegated_actions</code> is empty, no valid delegation path exists (or no permissions granted)</p> <p>Authorization: This endpoint is typically called by service accounts (authz-api) during authorization evaluation.</p>"},{"location":"development/delegations/#revoke","title":"Revoke","text":"<p>Revoke a delegation:</p> <pre><code>DELETE /v1/delegations\nAuthorization: Bearer &lt;user-token&gt;\nContent-Type: application/json\n\n{\n  \"principal_id\": \"carlo-uuid-1234\",\n  \"delegate_id\": \"yannick-uuid-5678\",\n  \"workflow_id\": \"workflow-abc-123\"\n}\n</code></pre> <p>Response: <pre><code>{\n  \"principal_id\": \"carlo-uuid-1234\",\n  \"delegate_id\": \"yannick-uuid-5678\",\n  \"workflow_id\": \"workflow-abc-123\",\n  \"revoked\": true\n}\n</code></pre></p> <p>Authorization: JWT <code>sub</code> must match <code>principal_id</code> (only the principal can revoke their own delegations).</p> <p>Important: Revocation sets <code>revoked_at</code> to the current timestamp. The delegation record remains in the database for audit purposes but is immediately invalidated.</p> <p>Revocation Cascade:</p> <p>When a delegation is revoked, all downstream delegations in the chain are immediately and automatically invalidated. This ensures security and prevents orphaned delegations.</p> <p>Example: - Chain: Carlo \u2192 Alexia \u2192 Martine \u2192 Sarah - Alexia revokes delegation to Martine - Result: Both Martine and Sarah immediately lose access to Carlo's resources - Reason: The delegation chain is broken at Alexia \u2192 Martine, making all downstream paths invalid</p> <p>Technical Implementation: - Delegation validation uses graph traversal (BFS) to find paths - If any edge in the path is revoked or expired, the entire chain fails validation - No explicit cascade delete is needed - validation naturally fails for broken chains - This ensures real-time enforcement of revocations without database triggers or batch jobs</p> <p>Key Properties: - Atomic: Revocation takes effect immediately on next authorization check - Transitive: Downstream delegates automatically lose access - Auditable: All delegation records remain in database with timestamps - Efficient: No recursive delete operations needed</p>"},{"location":"development/delegations/#expiration","title":"Expiration","text":"<p>Delegations automatically expire based on the <code>expires_at</code> timestamp:</p> <ul> <li>Expired delegations are excluded from validation queries by default</li> <li>Expired delegations can be included in listing queries via <code>include_expired=true</code></li> <li>No automatic cleanup process (expired records remain for audit)</li> </ul> <p>Configuration: <pre><code>DELEGATION_DEFAULT_EXPIRY_DAYS=7    # Default when expires_in_days not specified\nDELEGATION_MIN_EXPIRY_DAYS=1        # Minimum allowed expiry\nDELEGATION_MAX_EXPIRY_DAYS=365      # Maximum allowed expiry\n</code></pre></p>"},{"location":"development/delegations/#authorization-scenarios","title":"Authorization Scenarios","text":""},{"location":"development/delegations/#scenario-1-direct-delegation-travel-agent","title":"Scenario 1: Direct Delegation (Travel Agent)","text":"<p>Context:</p> <ul> <li>Carlo (traveler) creates a workflow</li> <li>Carlo delegates to Yannick (travel-agent) with scope <code>[\"execute\"]</code></li> <li>Yannick executes Carlo's workflow</li> </ul> <p>Authorization Flow:</p> <ol> <li>Domain-services-api receives request with Yannick's token</li> <li>Authz-api extracts <code>sub=yannick-uuid</code> from JWT</li> <li>Authz-api queries delegation-api: <code>validate_delegation(principal_id=carlo-uuid, delegate_id=yannick-uuid, workflow_id=workflow-123)</code></li> <li>Delegation-api performs BFS graph search:</li> <li>Finds direct edge: carlo-uuid \u2192 yannick-uuid</li> <li>Validates: not revoked, not expired, workflow matches (or unscoped)</li> <li>Returns: <code>{\"delegation_chain\": [\"carlo-uuid\", \"yannick-uuid\"], \"delegated_actions\": [\"execute\"]}</code></li> <li>Authz-api proceeds to OPA policy evaluation with delegation context (<code>delegated_actions</code> is non-empty)</li> <li>OPA evaluates business rules (autobook preferences, risk limits, etc.)</li> <li>Decision: Allow or Deny based on policy gates</li> </ol>"},{"location":"development/delegations/#scenario-2-transitive-delegation-office-manager-assistant","title":"Scenario 2: Transitive Delegation (Office Manager \u2192 Assistant)","text":"<p>Context:</p> <ul> <li>Carlo (traveler) delegates to Martine (office-manager) with scope <code>[\"read\", \"execute\"]</code></li> <li>Martine sub-delegates to Sophie (booking-assistant) with scope <code>[\"execute\"]</code></li> <li>Sophie executes Carlo's workflow</li> </ul> <p>Authorization Flow:</p> <ol> <li>Domain-services-api receives request with Sophie's token</li> <li>Authz-api queries delegation-api: <code>validate_delegation(principal_id=carlo-uuid, delegate_id=sophie-uuid, workflow_id=workflow-123)</code></li> <li>Delegation-api performs BFS graph search:</li> <li>Finds path: carlo-uuid \u2192 martine-uuid \u2192 sophie-uuid</li> <li>Edge 1 (carlo \u2192 martine): scope <code>[\"read\", \"execute\"]</code></li> <li>Edge 2 (martine \u2192 sophie): scope <code>[\"execute\"]</code></li> <li>Computes effective actions: <code>[\"read\", \"execute\"] \u2229 [\"execute\"] = [\"execute\"]</code></li> <li>Returns: <code>{\"delegation_chain\": [\"carlo-uuid\", \"martine-uuid\", \"sophie-uuid\"], \"delegated_actions\": [\"execute\"]}</code></li> <li>Authz-api proceeds to policy evaluation (<code>delegated_actions</code> contains \"execute\")</li> <li>Decision: Allow or Deny based on policy</li> </ol> <p>Key Points: - Delegation chains are resolved transitively (up to <code>max_depth=5</code> by default) - Effective permissions are the intersection of all edges in the chain - If any edge is revoked or expired, the entire chain is invalid</p>"},{"location":"development/delegations/#scenario-3-workflow-scoped-vs-unscoped-delegations","title":"Scenario 3: Workflow-Scoped vs Unscoped Delegations","text":"<p>Context:</p> <ul> <li>Carlo creates two workflows: <code>workflow-A</code> and <code>workflow-B</code></li> <li>Carlo delegates to Yannick with <code>workflow_id=workflow-A</code> (scoped delegation)</li> <li>Carlo also has an unscoped delegation to Martine (<code>workflow_id=null</code>)</li> </ul> <p>Authorization Flow:</p> <p>Yannick executes workflow-A: - Delegation validation: \u2713 (workflow-A matches delegation scope) - Result: Allowed (if policy passes)</p> <p>Yannick executes workflow-B: - Delegation validation: \u2717 (workflow-B does not match delegation scope) - Result: Denied with reason: <code>delegation_invalid</code></p> <p>Martine executes workflow-A or workflow-B: - Delegation validation: \u2713 (unscoped delegation matches any workflow) - Result: Allowed (if policy passes)</p> <p>Key Points: - Workflow-scoped delegations (<code>workflow_id</code> set) only apply to that specific workflow - Unscoped delegations (<code>workflow_id</code> is null) apply to all workflows owned by the principal - Both scoped and unscoped delegations are considered when validating (most permissive wins)</p>"},{"location":"development/delegations/#scenario-4-subdelegation-validation","title":"Scenario 4: Subdelegation Validation","text":"<p>Context:</p> <ul> <li>Carlo delegates to Martine with scope <code>[\"read\"]</code> (read-only)</li> <li>Martine attempts to sub-delegate to Sophie with scope <code>[\"execute\"]</code></li> </ul> <p>Authorization Flow:</p> <ol> <li>Martine calls <code>POST /v1/delegations</code> with:    <pre><code>{\n  \"principal_id\": \"carlo-uuid\",\n  \"delegate_id\": \"sophie-uuid\",\n  \"scope\": [\"execute\"]\n}\n</code></pre></li> <li>Delegation-api extracts <code>sub=martine-uuid</code> from Martine's JWT</li> <li>Delegation-api validates Martine's permissions:</li> <li>Queries: <code>validate_delegation(principal_id=carlo-uuid, delegate_id=martine-uuid)</code></li> <li>Returns: <code>{\"delegated_actions\": [\"read\"]}</code></li> <li>Delegation-api checks: <code>[\"execute\"] \u2286 [\"read\"]</code> \u2192 False</li> <li>Result: 400 Bad Request - \"Cannot delegate [execute]. You only have [read] permissions.\"</li> </ol> <p>Key Points: - Subdelegations cannot grant more permissions than the delegator possesses - Delegation creation automatically validates subdelegation constraints - Service accounts (persona=service) bypass subdelegation validation (trusted system components)</p>"},{"location":"development/delegations/#scenario-5-autonomous-ai-agent-no-delegation-required","title":"Scenario 5: Autonomous AI Agent (No Delegation Required)","text":"<p>Context:</p> <ul> <li>Carlo (traveler) has <code>autobook_consent=true</code> in his persona</li> <li>AI agent attempts to execute Carlo's workflow</li> <li>No delegation exists from Carlo to the AI agent</li> </ul> <p>Authorization Flow:</p> <ol> <li>AI-agent-api calls domain-services-api with service token</li> <li>AuthZEN request: <code>subject.persona=\"ai-agent\"</code>, <code>context.principal.id=carlo-uuid</code></li> <li>Authz-api queries delegation-api: <code>validate_delegation(principal_id=carlo-uuid, delegate_id=ai-agent)</code></li> <li>Delegation-api returns: <code>{\"delegated_actions\": []}</code> (no delegation exists)</li> <li>Authz-api checks OPA policy gate: <code>has_consent</code></li> <li>Carlo's persona has <code>autobook_consent=true</code></li> <li>Policy allows autonomous execution without delegation</li> <li>OPA evaluates business rules (cost limits, risk, leadtime, etc.)</li> <li>Decision: Allow or Deny based on ABAC gates</li> </ol> <p>Key Points: - AI agents can operate autonomously when the user has granted consent via their persona - Delegation is NOT required for autonomous execution (consent bypasses delegation check) - This enables frictionless automation while maintaining user control</p>"},{"location":"development/delegations/#troubleshooting","title":"Troubleshooting","text":""},{"location":"development/delegations/#delegation-not-found","title":"Delegation Not Found","text":"<p>Symptom: Authorization denied with <code>delegation_invalid</code> reason code</p> <p>Causes:</p> <ol> <li>Delegation never created</li> <li>Delegation expired</li> <li>Delegation revoked</li> <li>Workflow-scoped delegation doesn't match requested workflow</li> </ol> <p>Debug Steps:</p> <ol> <li> <p>Check if delegation exists:    <pre><code>curl -H \"Authorization: Bearer &lt;user-token&gt;\" \\\n  \"https://delegation-api/v1/delegations?principal_id=&lt;principal-id&gt;&amp;delegate_id=&lt;delegate-id&gt;\"\n</code></pre></p> </li> <li> <p>Validate delegation explicitly:    <pre><code>curl -H \"Authorization: Bearer &lt;service-token&gt;\" \\\n  \"https://delegation-api/v1/delegations/validate?principal_id=&lt;principal-id&gt;&amp;delegate_id=&lt;delegate-id&gt;&amp;workflow_id=&lt;workflow-id&gt;\"\n</code></pre></p> </li> <li> <p>Check delegation-api logs:    <pre><code># Local\ndocker compose logs -f flowpilot-delegation-api\n\n# GCP\ngcloud logging read \"resource.labels.service_name=flowpilot-delegation-api\" --limit=50\n</code></pre></p> </li> </ol>"},{"location":"development/delegations/#subdelegation-denied","title":"Subdelegation Denied","text":"<p>Symptom: 400 Bad Request - \"Cannot delegate [execute]. You only have [read] permissions.\"</p> <p>Causes:</p> <ol> <li>Delegator attempting to grant more permissions than they possess</li> <li>Delegation chain has restricted scope</li> </ol> <p>Resolution:</p> <ol> <li> <p>Check delegator's permissions:    <pre><code>curl -H \"Authorization: Bearer &lt;service-token&gt;\" \\\n  \"https://delegation-api/v1/delegations/validate?principal_id=&lt;owner-id&gt;&amp;delegate_id=&lt;delegator-id&gt;\"\n</code></pre></p> </li> <li> <p>Adjust requested scope to match delegator's permissions:    <pre><code>{\n  \"scope\": [\"read\"]  // Instead of [\"execute\"]\n}\n</code></pre></p> </li> </ol>"},{"location":"development/delegations/#transitive-delegation-fails","title":"Transitive Delegation Fails","text":"<p>Symptom: Delegation validation returns <code>valid: false</code> despite multi-hop chain existing</p> <p>Causes:</p> <ol> <li>One edge in the chain is expired or revoked</li> <li>Effective permissions reduced to empty set via intersection</li> <li>Chain exceeds <code>max_depth</code> limit (default: 5)</li> </ol> <p>Debug Steps:</p> <ol> <li> <p>Check each edge in the chain individually:    <pre><code># Edge 1: A \u2192 B\ncurl \"https://delegation-api/v1/delegations?principal_id=A&amp;delegate_id=B\"\n\n# Edge 2: B \u2192 C\ncurl \"https://delegation-api/v1/delegations?principal_id=B&amp;delegate_id=C\"\n</code></pre></p> </li> <li> <p>Verify scope compatibility:</p> </li> <li>If A\u2192B has scope <code>[\"read\"]</code> and B\u2192C has scope <code>[\"execute\"]</code></li> <li> <p>Effective scope: <code>[\"read\"] \u2229 [\"execute\"] = []</code> (empty, invalid)</p> </li> <li> <p>Increase max_depth if needed (only if chain length is legitimate):    <pre><code># In delegation_core.py\npath_result = self.graphdb.find_delegation_path(\n    principal_id=principal_id,\n    delegate_id=delegate_id,\n    workflow_id=workflow_id,\n    max_depth=10,  # Increase from default 5\n)\n</code></pre></p> </li> </ol>"},{"location":"development/delegations/#best-practices","title":"Best Practices","text":"<ol> <li>Use workflow-scoped delegations for sensitive operations - Limit delegation scope to specific workflows when possible</li> <li>Set reasonable expiration times - Default 7 days is appropriate for most use cases; avoid excessive expiry periods</li> <li>Revoke delegations when no longer needed - Explicit revocation is better than waiting for expiration</li> <li>Use unscoped delegations sparingly - Workflow-scoped delegations provide better security boundaries</li> <li>Monitor delegation chains - Keep chains short (1-2 hops) to maintain clarity and auditability</li> <li>Grant minimal scope - Start with <code>[\"read\"]</code> and expand to <code>[\"execute\"]</code> only when necessary</li> <li>Validate subdelegations carefully - Ensure delegators understand they can only grant permissions they possess</li> <li>Use automatic delegation for AI agents - Let domain-services-api create agent delegations automatically</li> <li>Include delegation context in audit logs - Track delegation chains for security and compliance</li> <li>Test delegation scenarios thoroughly - Verify both direct and transitive delegations work as expected</li> <li>Document delegation relationships - Maintain clear documentation of who can delegate to whom</li> <li>Use service accounts for system delegations - Service accounts bypass subdelegation validation (trusted components)</li> <li>Configure appropriate max_depth - Default 5 hops is usually sufficient; increase only for specific use cases</li> <li>Handle duplicate creation errors gracefully - The API enforces uniqueness by failing duplicate creates with HTTP 400; provisioning code should check for existence first or catch duplicate errors</li> <li>Implement idempotency in provisioning scripts - Scripts should verify existing delegations match desired state before attempting to create new ones</li> </ol>"},{"location":"development/delegations/#related-documentation","title":"Related Documentation","text":"<ul> <li>Policy Development Guide - How OPA policies use delegation data</li> <li>Persona Development Guide - How personas interact with delegations</li> <li>Authorization Architecture - Overall authorization flow</li> <li>API Reference: Delegation API - Full API specification</li> </ul>"},{"location":"development/identities/","title":"Persona vs Identity","text":"<p>This document explains FlowPilot\u2019s approach to user accounts and, just as importantly, what FlowPilot deliberately does not model or manage.</p> <p>FlowPilot is identity-provider agnostic. Authentication and account management are delegated entirely to an external Identity Provider (IdP). FlowPilot itself does not manage user accounts, credentials, or identity attributes. Instead, it focuses exclusively on authorization, using personas and persona-specific attributes under its own control.</p>"},{"location":"development/identities/#design-principles","title":"Design Principles","text":""},{"location":"development/identities/#bring-your-own-identity-provider","title":"Bring Your Own Identity Provider","text":"<p>User authentication is handled by an external IdP such as Firebase (production) or Keycloak (local development) and thus FlowPilot supports a Bring Your Own Identity Provider. The IdP is responsible for:</p> <ul> <li>User account creation and lifecycle</li> <li>Credential management</li> <li>Authentication flows (passwords, MFA, federation, etc.)</li> <li>Issuance of OIDC ID tokens</li> </ul> <p>FlowPilot services do not depend on any IdP-managed user attributes: - no username - no email address - no name - no group or role claims</p> <p>From FlowPilot\u2019s perspective, the only relevant output of authentication is a stable subject identifier (<code>sub</code>).</p>"},{"location":"development/identities/#no-identity-authentication-api-in-flowpilot","title":"No Identity &amp; Authentication API in FlowPilot","text":"<p>FlowPilot intentionally does not provide an API to manage user profiles.</p> <p>User profiles, in the traditional sense (identity attributes, contact information, organizational metadata), are considered out of scope and belong to the IdP domain.</p> <p>As a result:</p> <ul> <li>Developers are free to model IdP accounts as they see fit</li> <li>FlowPilot does not read, store, or expose IdP attributes</li> <li>FlowPilot services never receive ID tokens after initial token exchange</li> </ul> <p>This keeps FlowPilot cleanly separated from identity concerns and avoids tight coupling to any specific IdP.</p>"},{"location":"development/identities/#authorization-is-persona-driven","title":"Authorization Is Persona-Driven","text":"<p>All authorization decisions in FlowPilot are based on personas, not on user profiles.</p> <p>A persona represents: - a business role - a mandate - or a responsibility assumed by a user in a given context</p> <p>Personas and persona-specific attributes are:</p> <ul> <li>explicitly modeled in FlowPilot</li> <li>owned and managed by the user (or delegated administrators)</li> <li>evaluated by authorization policies (OPA / Rego)</li> </ul> <p>This means that FlowPilot controls all data that influences authorization, independently from the IdP.</p>"},{"location":"development/identities/#privacy-by-design","title":"Privacy by Design","text":"<p>Because FlowPilot does not consume IdP attributes:</p> <ul> <li>No Personally Identifiable Information (PII) enters FlowPilot systems</li> <li>Tokens used between backend services contain only a pseudonymous UUID (<code>sub</code>)</li> <li>Persona attributes are fetched on demand and only for authorization decisions</li> <li>Domain services, AI agents, and logs never see identity data</li> </ul> <p>This architecture ensures:</p> <ul> <li>minimal data exposure</li> <li>reduced breach impact</li> <li>strong GDPR alignment</li> <li>clear separation between identity and authorization</li> </ul>"},{"location":"development/identities/#how-user-identity-is-represented","title":"How User Identity Is Represented","text":"<p>From FlowPilot\u2019s point of view, a \u201cuser\u201d is represented by:</p> <pre><code>{\n  \"sub\": \"89eb5366-bab3-46e4-b8e1-abc5f2ea4631\"\n}\n</code></pre> <p>This <code>sub</code> value:</p> <ul> <li>originates from the IdP</li> <li>is stable across sessions</li> <li>is opaque and non-meaningful</li> <li>is used solely as a key to:</li> <li>fetch personas</li> <li>resolve delegation relationships</li> <li>evaluate authorization policies</li> </ul> <p>No other identity attributes are required.</p>"},{"location":"development/identities/#relationship-to-personas","title":"Relationship to Personas","text":"<p>Personas are linked to users by <code>sub</code>, part of each persona record. The <code>sub</code> is a pseudononymous identifier and not PII.</p> <p>Key distinctions:</p> <ul> <li>User (IdP) </li> <li>authenticated entity  </li> <li>managed externally  </li> <li> <p>opaque to FlowPilot  </p> </li> <li> <p>Persona (FlowPilot) </p> </li> <li>authorization construct  </li> <li>business-role specific  </li> <li>policy-relevant  </li> <li>explicitly modeled and validated  </li> </ul> <p>A single user (<code>sub</code>) may own multiple personas, each with its own lifecycle, attributes, and authorization semantics.</p>"},{"location":"development/identities/#architectural-consequences","title":"Architectural Consequences","text":"<p>This design has several important consequences:</p> <ul> <li>FlowPilot remains portable across IdPs</li> <li>Authorization logic is fully under FlowPilot\u2019s control</li> <li>PII cannot accidentally leak into policies, logs, or AI prompts</li> <li>Identity concerns do not contaminate domain or policy logic</li> <li>Personas can evolve independently of authentication mechanisms</li> </ul> <p>In short: FlowPilot treats identity as an external fact and authorization as an internal responsibility.</p>"},{"location":"development/identities/#related-documentation","title":"Related Documentation","text":"<ul> <li>Persona Guide</li> <li>Authentication Architecture</li> <li>Policy Development Guide</li> </ul>"},{"location":"development/personas/","title":"Persona Management","text":"<p>This guide explains FlowPilot's persona model, including the data model, API operations, authorization rules, and technical implementation details.</p>"},{"location":"development/personas/#overview","title":"Overview","text":"<p>A persona represents a business role that a user assumes in a specific context. Personas are the core abstraction in FlowPilot\u2019s authorization model and directly drive policy decisions for both autonomous AI execution and delegated access.</p> <p>Rather than binding static permissions to user accounts, FlowPilot evaluates authorization against the activated persona provided with each request. Persona activation is not a platform-wide setting; it is scoped to the client app. The client app determines which persona is active; either automatically, based on the app's intended audience, or explicitly via a user-driven persona selection.</p>"},{"location":"development/personas/#key-concepts","title":"Key concepts","text":"<ul> <li>A single user may have multiple personas (for example, <code>traveler</code> and <code>travel-agent</code>)</li> <li>Each authorization request is evaluated against exactly one selected persona</li> <li>Personas have explicit lifecycle state with temporal validity (<code>valid_from</code>, <code>valid_till</code>) and operational status (configurable and policy-relevant, e.g. <code>active</code>, <code>inactive</code>, <code>suspended</code>, <code>pending</code>, <code>revoked</code>)</li> <li>Personas also encapsulate user's preferences, such as consent for autonomous decisions, limits on cost or effort and risk tolerance levels</li> <li>Personas are user-owned, independently configurable and their assignment is possibly subject to a strict onboarding process</li> </ul>"},{"location":"development/personas/#why-personas-matter","title":"Why Personas Matter","text":"<p>Introducing personas allows authorization policies to depend on business intent, not on technical account and application structure.</p> <p>A FlowPilot persona models the business role, and in fact the mandate a person holds at a given moment. Each persona carries only the attributes relevant to that mandate and can be self-declared and managed independently from the underlying user account.</p> <p>This enables several important architectural properties.</p>"},{"location":"development/personas/#1-persona-level-lifecycle-management","title":"1. Persona-level lifecycle management","text":"<p>User lifecycle management moves from the account level to the persona level:</p> <ul> <li>When someone leaves a role or function, only the corresponding persona needs to be deactivated</li> <li>The underlying user account can remain intact</li> <li>Users can onboard early and activate personas only when appropriate</li> </ul> <p>This avoids account churn and reduces operational friction.</p>"},{"location":"development/personas/#2-delegated-security-administration","title":"2. Delegated security administration","text":"<p>Persona ownership enables delegated security administration:</p> <ul> <li>Users manage their own personas and persona attributes</li> <li>Security decisions are made closest to the source of truth</li> <li>No central administrator is required to continuously assign roles, groups, or permissions</li> </ul> <p>This improves: - timeliness - accuracy - appropriateness - freshness of authorization data</p>"},{"location":"development/personas/#3-segregation-of-duties-by-design","title":"3. Segregation of duties by design","text":"<p>Segregation of duties becomes straightforward:</p> <ul> <li>Different duties are represented as different personas</li> <li>Policies can enforce that certain actions require distinct personas</li> <li>Conflicts are prevented structurally rather than procedurally</li> </ul>"},{"location":"development/personas/#4-user-managed-access","title":"4. User Managed Access","text":"<p>Personas provide a clean foundation for users managing access in a policy-constrained way:</p> <ul> <li>Users explicitly control which personas are active</li> <li>Delegation operates on personas, not raw identities</li> <li>Users are still subject to policies that remain declarative and auditable</li> </ul>"},{"location":"development/personas/#architectural-impact","title":"Architectural Impact","text":"<p>FlowPilot personas combine the strengths of RBAC, ABAC and ReBAC:</p> <ul> <li>RBAC-like clarity through named business roles</li> <li>ABAC-like flexibility through persona-specific attributes</li> <li>ReBAC-like delegation through persona-driven relationships</li> </ul> <p>At the same time, persona-based administration significantly simplifies access management at scale:</p> <ul> <li>No global role explosion</li> <li>No central permission assignment bottleneck</li> <li>No need to expose identity or PII to policies</li> </ul> <p>Instead, authorization becomes: - explicit - decentralized - policy-driven - scalable by design</p> <p>In FlowPilot, personas place users at the center of their own authorization model, controlling not just who they are, but how and when they may act.</p>"},{"location":"development/personas/#persona-data-model","title":"Persona Data Model","text":""},{"location":"development/personas/#core-attributes","title":"Core Attributes","text":"Field Type Description <code>persona_id</code> String Composite unique identifier: <code>{user_sub}_{title}</code> - enforces uniqueness at database level <code>user_sub</code> String Owner's user ID (Firebase UID or Keycloak sub) <code>title</code> String Persona title (e.g., \"traveler\", \"travel-agent\") <code>status</code> String Current status: defined in policy manifest (e.g., \"pending\", \"active\", \"inactive\", \"suspended\", \"revoked\") <code>scope</code> Array[String] Denotes a community, organisation, family <code>consent</code> Boolean Whether user allows autonomous execution of workflows for this persona <code>valid_from</code> ISO 8601 Timestamp when persona becomes active <code>valid_till</code> ISO 8601 Timestamp when persona expires <code>created_at</code> ISO 8601 Creation timestamp <code>updated_at</code> ISO 8601 Last modification timestamp <p>Important: Each user can have only one persona per title. The <code>persona_id</code> is a composite key formed from <code>user_sub</code> and <code>title</code> (e.g., <code>PKbHpCqDnLcNywEo8pev8yQmoU43_traveler</code>). This enforces uniqueness at the database level and makes persona creation fully idempotent.</p> <p>In addition to the persona lifecycle management attributes, each persona can also have a number of custom attributes specific to the business use case. These are configured in the manifest (see below).</p>"},{"location":"development/personas/#persona-configuration","title":"Persona Configuration","text":"<p>The persona titles, statuses and custom attributes are defined in the policy manifest as the single source of truth for both authorization policies and profil/persona management.</p> <p>A system-defined persona <code>title</code> is <code>ai-agent</code>. This is used by the back-end and by agentic AI systems.</p> <p>Configuration Location: <code>infra/opa/policies/travel/manifest.yaml</code></p> <p>Key Benefits of using the manifest: - Customizable - Can easily be customized for a specific business use case - Single source of truth - All persona configuration in one manifest file and used by both applications and the policy - Centralized updates - Change persona configuration in one place - Policy alignment - Persona titles and statuses automatically match OPA policy expectations, which is use case specific</p> <p>Important Note on validation and defaulting responsibility - persona-api: Validates that required attributes are PRESENT (not None) and sets a default value when not present. Does NOT validate ranges or policy-specific constraints - authz-api: Assumes persona-api did its job and is not bypassed. So it passes attributes to OPA without validation or defaulting - OPA policy: Performs ALL policy-specific validation (e.g., range checks) that is specific to the business use case</p> <p>This separation ensures the system is extensible to other policies and business use cases without hardcoding policy logic in the API layer. This makes the platform truly a generic SaaS service</p>"},{"location":"development/personas/#manifest-structure","title":"Manifest Structure","text":"<p>The manifest's <code>persona_config</code> section defines <code>status</code>, <code>title</code> and a series of custom attributes. For the \"travel\" use case, FlowPilot defined the following <code>status</code>, <code>title</code> and autobook attributes. The latter enable and steer autonomous AI booking. Their values are validated and normalized by the persona-api and coerced to the type specified. Their values are also defaulted in case they are optional and a default value is provided. A default value of <code>null</code> means that the attribute will only be created when it explicitly has a value.</p> <pre><code>persona_config:\n  # Allowed persona status values (lifecycle states)\n  persona_statuses:\n    - pending      # Persona created but not yet activated\n    - active       # Persona is active and can be used\n    - inactive     # Persona is disabled by user\n    - suspended    # Persona temporarily disabled by admin (e.g., suspected behaviour)\n    - revoked      # Persona permanently disabled (e.g., mistake or compliance issue)\n\n  # Persona titles with rich metadata\n  persona_titles:\n    - title: visitor\n      description: \"End user who may be interested in travel options or the itinerary\"\n      can-be-invited: true\n      can-be-delegated-to: false\n      allowed-actions: [read]\n\n    - title: traveler\n      description: \"End users who book travel for themselves and for whom autobook preferences apply to their itineraries\"\n      can-be-invited: true\n      can-be-delegated-to: false\n      allowed-actions: [read, create, update, execute, delete]\n\n    - title: business-traveler\n      description: \"End users who book travel for business purposes with specific autobook preferences\"\n      can-be-invited: true\n      can-be-delegated-to: false\n      allowed-actions: [read, create, update, execute, delete]\n\n    - title: travel-agent\n      description: \"Travel agent who can execute workflows on behalf of travelers, if explicitly delegated\"\n      can-be-invited: false\n      can-be-delegated-to: true\n      allowed-actions: [read, create, update, execute, delete]\n\n    - title: office-manager\n      description: \"Office manager who can consult and update someone's booking, but cannot execute it\"\n      can-be-invited: false\n      can-be-delegated-to: true\n      allowed-actions: [read, create, update]\n\n    - title: booking-assistant\n      description: \"Booking assistant who can manage and execute bookings on behalf of travelers\"\n      can-be-invited: false\n      can-be-delegated-to: true\n      allowed-actions: [read, create, update, execute]\n\n    - title: user-admin\n      description: \"Supra-level administrator with full permissions to update personas of other users\"\n      can-be-invited: false\n      can-be-delegated-to: true\n      allowed-actions: [read, create, update, execute, delete]\n\n  # Persona custom attributes\n  attributes:\n  - name: autobook_price\n    type: integer\n    source: persona\n    default: 500\n    required: false # when not given, the default value is set\n    description: \"Maximum trip cost for autonomous booking (EUR)\"\n\n  - name: autobook_leadtime\n    type: integer\n    source: persona\n    default: 7\n    required: false\n    description: \"Minimum days before departure for autonomous booking\"\n\n  - name: autobook_risklevel\n    type: integer\n    source: persona\n    default: 3\n    required: false\n    description: \"Maximum airline risk score for autonomous booking (1-5 scale)\"\n</code></pre>"},{"location":"development/personas/#architecture-flow","title":"Architecture Flow","text":"<pre><code>manifest.yaml (SOURCE OF TRUTH)\n     \u2193\n     \u251c\u2500\u2192 Python Services (via persona_config.py)\n     \u2502   \u251c\u2500\u2192 persona-api (validates titles &amp; statuses)\n     \u2502   \u2514\u2500\u2192 authz-api (loads attribute schema)\n     \u2502\n     \u2514\u2500\u2192 [generation script] \u2192 persona_config.json\n                                      \u2193\n                                   OPA Policy Engine\n</code></pre> <p>The <code>persona_config.json</code> file is auto-generated from <code>manifest.yaml</code>: - For local development: Run <code>make generate-opa-config</code> - For Docker/Cloud Run: Auto-generated during build process - Never edit <code>persona_config.json</code> directly - it will be overwritten</p>"},{"location":"development/personas/#example-persona-document","title":"Example Persona Document","text":"<pre><code>{\n  \"persona_id\": \"PKbHpCqDnLcNywEo8pev8yQmoU43_business-traveler\",\n  \"user_sub\": \"PKbHpCqDnLcNywEo8pev8yQmoU43\",\n  \"title\": \"business-traveler\",\n  \"status\": \"active\",\n  \"scope\": [\"nike\"],\n  \"valid_from\": \"2026-01-11T17:00:00Z\",\n  \"valid_till\": \"2026-12-31T23:59:59Z\",\n  \"created_at\": \"2026-01-11T17:00:00Z\",\n  \"updated_at\": \"2026-01-13T17:00:00Z\",\n  \"consent\": true,\n  \"autobook_price\": 10000,\n  \"autobook_leadtime\": 7,\n  \"autobook_risklevel\": 5\n}\n</code></pre> <p>Note the <code>persona_id</code> format: <code>{user_sub}_{title}</code>. This composite ID ensures that each user can have only one persona per title.</p>"},{"location":"development/personas/#persona-lifecycle","title":"Persona Lifecycle","text":""},{"location":"development/personas/#persona-api","title":"Persona-API","text":"<p>Purpose: Persona lifecycle management (CRUD operations)</p> <p>Endpoints:</p> <ul> <li><code>POST /v1/personas</code> - Create persona (idempotent)</li> <li><code>GET /v1/personas</code> - List user's personas</li> <li><code>GET /v1/personas/{persona_id}</code> - Get specific persona</li> <li><code>PUT /v1/personas/{persona_id}</code> - Update persona</li> <li><code>DELETE /v1/personas/{persona_id}</code> - Delete persona</li> <li><code>GET /v1/users/{user_sub}/personas</code> - List personas for any user (service accounts only)</li> </ul> <p>Authorization:</p> <ul> <li>User endpoints: JWT <code>sub</code> must match persona owner</li> <li>Service endpoint: Requires service account token (Keycloak: <code>client_id=flowpilot-agent</code>, GCP: <code>gserviceaccount.com</code> in email)</li> </ul> <p>Code Location: <code>flowpilot-services/persona-api/</code></p> <p>Validation Rules:</p> <ul> <li><code>title</code> must be one of the allowed persona titles defined in <code>persona_config.persona_titles</code> in the policy manifest</li> <li><code>status</code> must be one of the allowed statuses defined in <code>persona_config.persona_statuses</code> in the policy manifest</li> <li><code>scope</code> must be a non-empty array of action strings</li> <li><code>valid_from</code> &amp; <code>valid_till</code> must be valid ISO 8601 timestamps</li> <li>Custom attributes (e.g., <code>autobook_price</code>, <code>autobook_leadtime</code>, <code>autobook_risklevel</code>) are optional and validated according to the <code>attributes</code> section of the policy manifest</li> <li>Uniqueness: Each user can have only one persona per title (enforced at database level via composite ID)</li> </ul> <p>Important Notes: The service fails fast at startup if the policy manifest cannot be loaded, ensuring persona configuration is always consistent with authorization policies</p> <p>Uniqueness Enforcement: Each user can have only one persona per title (enforced at database level via composite ID). Attempting to create a duplicate persona raises a <code>ValueError</code> with HTTP 400, suggesting to use PUT/PATCH for updates instead.</p> <p>Idempotency Handling: The API is NOT idempotent by design. Duplicate creation attempts fail explicitly, requiring callers to check for existence before creating or catch the error and use update endpoints. This ensures intentional create vs update semantics.</p>"},{"location":"development/personas/#create","title":"Create","text":"<p>Personas are created via the persona-api POST /v1/personas endpoint.</p> <p>Request: <pre><code>POST /v1/personas\nAuthorization: Bearer &lt;access-token&gt;\nContent-Type: application/json\n\n{\n  \"title\": \"traveler\",\n  \"scope\": [\"read\", \"execute\"],\n  \"valid_from\": \"2024-01-01T00:00:00Z\",\n  \"valid_till\": \"2026-12-31T23:59:59Z\",\n  \"status\": \"active\",\n  \"autobook_consent\": true,\n  \"autobook_price\": 5000,\n  \"autobook_leadtime\": 7,\n  \"autobook_risklevel\": 3\n}\n</code></pre></p> <p>Response (HTTP 201): <pre><code>{\n  \"persona_id\": \"PKbHpCqDnLcNywEo8pev8yQmoU43_traveler\",\n  \"user_sub\": \"PKbHpCqDnLcNywEo8pev8yQmoU43\",\n  \"title\": \"traveler\",\n  \"status\": \"active\",\n  \"scope\": [\"read\", \"execute\"],\n  \"valid_from\": \"2024-01-01T00:00:00Z\",\n  \"valid_till\": \"2026-12-31T23:59:59Z\",\n  \"created_at\": \"2026-01-13T17:00:00Z\",\n  \"updated_at\": \"2026-01-13T17:00:00Z\",\n  \"autobook_consent\": true,\n  \"autobook_price\": 5000,\n  \"autobook_leadtime\": 7,\n  \"autobook_risklevel\": 3\n}\n</code></pre></p> <p>Authorization: The user must be authenticated. The persona is created for the authenticated user (extracted from JWT <code>sub</code> claim).</p> <p>Uniqueness: If a persona with the same <code>title</code> already exists for the authenticated user, the API returns HTTP 400 with an error message: \"Persona with title '{title}' already exists for this user. Use PATCH/PUT (update) instead of POST (create) to modify it.\" This explicit failure ensures clear semantics between persona creation and modification.</p> <p>Idempotency Handling: The API is NOT idempotent by design. Duplicate creation attempts fail explicitly to: - Prevent accidental expiry modifications without explicit revocation - Ensure callers understand persona lifecycle - Maintain clear audit trail of the persona lifecycle (create \u2192 revoke \u2192 recreate)</p> <p>For Idempotent Provisioning: Provisioning scripts should implement their own idempotency logic by checking for existence first (GET /v1/personas) or catching the 400 error and treating it as success if the existing persona matches desired state.</p>"},{"location":"development/personas/#fetch","title":"Fetch","text":"<p>Fetch a specific persona by ID:</p> <pre><code>GET /v1/personas/{persona_id}\nAuthorization: Bearer &lt;access-token&gt;\n</code></pre> <p>Authorization: The user must be authenticated. </p>"},{"location":"development/personas/#update","title":"Update","text":"<p>Modify persona attributes:</p> <pre><code>PUT /v1/personas/{persona_id}\nAuthorization: Bearer &lt;access-token&gt;\nContent-Type: application/json\n\n{\n  \"autobook_price\": 8000,\n  \"autobook_leadtime\": 14,\n  \"status\": \"active\"\n}\n</code></pre> <p>Authorization: The persona must belong to the authenticated user.</p>"},{"location":"development/personas/#list","title":"List","text":"<p>Users can list their own personas:</p> <pre><code>GET /v1/personas?status=active\nAuthorization: Bearer &lt;access-token&gt;\n</code></pre> <p>Service accounts can list personas for any user:</p> <pre><code>GET /v1/users/{user_sub}/personas?status=active\nAuthorization: Bearer &lt;service-token&gt;\n</code></pre> <p>This endpoint is used by authz-api to fetch persona data for authorization decisions.</p> <p>All fields are optional (partial update). Only provided fields are updated.</p> <p>Authorization: The persona must belong to the authenticated user.</p>"},{"location":"development/personas/#delete","title":"Delete","text":"<p>Delete a persona:</p> <pre><code>DELETE /v1/personas/{persona_id}\nAuthorization: Bearer &lt;user-token&gt;\n</code></pre> <p>Authorization: The persona must belong to the authenticated user.</p>"},{"location":"development/personas/#authorization-scenarios","title":"Authorization Scenarios","text":""},{"location":"development/personas/#scenario-1-owner-with-traveler-persona","title":"Scenario 1: Owner with Traveler Persona","text":"<p>Context:</p> <ul> <li>Carlo (traveler) creates a workflow</li> <li>Carlo executes his own workflow</li> </ul> <p>Authorization Flow:</p> <ol> <li>Domain-services-api receives request with Carlo's token</li> <li>Authz-api extracts <code>sub=carlo-uuid</code> from JWT</li> <li>Authz-api fetches Carlo's \"traveler\" persona from persona-api</li> <li>OPA evaluates:<ul> <li><code>authorized_principal</code>: \u2713 (owner == principal)</li> <li><code>persona_valid</code>: \u2713 (traveler == traveler)</li> <li><code>owner_persona_active</code>: \u2713 (status == \"active\")</li> <li><code>owner_persona_valid_time</code>: \u2713 (current time within range)</li> <li><code>has_consent</code>: \u2713 (autobook_consent == true)</li> <li>Other gates...</li> </ul> </li> <li>Decision: Allow (if all gates pass)</li> </ol>"},{"location":"development/personas/#scenario-2-delegated-travel-agent","title":"Scenario 2: Delegated Travel Agent","text":"<p>Context:</p> <ul> <li>Carlo (traveler) delegates to Yannick (travel-agent)</li> <li>Yannick executes Carlo's workflow</li> </ul> <p>Authorization Flow:</p> <ol> <li>Domain-services-api receives request with Yannick's token</li> <li>Authz-api extracts <code>sub=yannick-uuid</code> from JWT</li> <li>Authz-api queries delegation-api: valid delegation exists</li> <li>Authz-api fetches Carlo's \"traveler\" persona (resource owner)</li> <li>OPA evaluates:<ul> <li><code>authorized_principal</code>: \u2713 (valid delegation with \"execute\" action)</li> <li><code>persona_valid</code>: \u2713 (Yannick's persona \"travel-agent\" is an agent persona)</li> <li><code>owner_persona_active</code>: \u2713 (Carlo's persona status == \"active\")</li> <li><code>owner_persona_valid_time</code>: \u2713 (Carlo's persona is valid)</li> <li><code>has_consent</code>: \u2713 (Carlo's autobook_consent == true)</li> <li>Other gates...</li> </ul> </li> <li>Decision: Allow (if all gates pass)</li> </ol>"},{"location":"development/personas/#scenario-3-autonomous-ai-agent","title":"Scenario 3: Autonomous AI Agent","text":"<p>Context:</p> <ul> <li>AI agent attempts to book autonomously (no delegation)</li> <li>Carlo's workflow with autobook consent</li> </ul> <p>Authorization Flow:</p> <ol> <li>AI-agent-api calls domain-services-api with service token</li> <li>AuthZEN request: <code>subject.persona = \"ai-agent\"</code>, <code>context.principal.id = carlo-uuid</code></li> <li>Authz-api fetches Carlo's \"traveler\" persona</li> <li>OPA evaluates:<ul> <li><code>authorized_principal</code>: \u2713 (autobook_consent == true, no delegation required)</li> <li><code>persona_valid</code>: \u2713 (context.principal.persona == owner.persona)</li> <li><code>owner_persona_active</code>: \u2713 (status == \"active\")</li> <li><code>owner_persona_valid_time</code>: \u2713 (within valid time range)</li> <li><code>has_consent</code>: \u2713 (autobook_consent == true)</li> <li><code>within_cost_limit</code>: Check Carlo's autobook_price</li> <li><code>sufficient_advance</code>: Check Carlo's autobook_leadtime</li> <li><code>acceptable_risk</code>: Check Carlo's autobook_risklevel</li> </ul> </li> <li>Decision: Allow or Deny based on ABAC gates</li> </ol>"},{"location":"development/personas/#scenario-4-persona-mismatch","title":"Scenario 4: Persona Mismatch","text":"<p>Context:</p> <ul> <li>Martine has two personas: \"traveler\" and \"office-manager\"</li> <li>Martine (office-manager) tries to execute her own workflow created with \"traveler\" persona</li> </ul> <p>Authorization Flow:</p> <ol> <li>Workflow was created with <code>owner.persona = \"traveler\"</code></li> <li>Martine's request has <code>subject.persona = \"office-manager\"</code></li> <li>OPA evaluates:<ul> <li><code>authorized_principal</code>: \u2713 (owner == principal)</li> <li><code>persona_valid</code>: \u2717 (office-manager \u2260 traveler, and office-manager is not allowed for owner execution)</li> </ul> </li> <li>Decision: Deny with reason_code <code>\"auto_book.persona_mismatch\"</code></li> </ol> <p>Resolution: Martine must switch to her \"traveler\" persona when executing her own workflows.</p>"},{"location":"development/personas/#troubleshooting","title":"Troubleshooting","text":""},{"location":"development/personas/#persona-not-found","title":"Persona Not Found","text":"<p>Symptom: Authorization denied with <code>auto_book.no_consent</code> despite user having consent</p> <p>Causes:</p> <ol> <li>Persona not created or provisioned</li> <li>Persona fetch fails (403, 404, timeout)</li> <li>Service account cannot access persona-api</li> </ol> <p>Debug Steps:</p> <ol> <li> <p>Verify persona exists:    <pre><code>curl -H \"Authorization: Bearer &lt;user-token&gt;\" \\\n  https://persona-api/v1/personas\n</code></pre></p> </li> <li> <p>Check authz-api logs for persona fetch errors:    <pre><code>gcloud logging read \"resource.labels.service_name=flowpilot-authz-api \\\n  AND (textPayload=~'persona' OR jsonPayload.error=~'persona')\" \\\n  --limit=20\n</code></pre></p> </li> <li> <p>Verify service account can access persona-api:    <pre><code># Get service token (GCP)\ncurl -H \"Metadata-Flavor: Google\" \\\n  \"http://metadata.google.internal/computeMetadata/v1/instance/service-accounts/default/identity?audience=flowpilot-services\"\n\n# Test access\ncurl -H \"Authorization: Bearer &lt;service-token&gt;\" \\\n  https://persona-api/v1/users/&lt;user-sub&gt;/personas\n</code></pre></p> </li> </ol>"},{"location":"development/personas/#persona-status-denied","title":"Persona Status Denied","text":"<p>Symptom: Authorization denied with <code>persona.status</code> is <code>inactive</code> or <code>revoked</code></p> <p>Causes:</p> <ol> <li>Persona status is not \"active\"</li> <li>Current time is outside valid_from/valid_till range</li> </ol> <p>Resolution:</p> <ol> <li> <p>Update persona status:    <pre><code>curl -X PUT https://persona-api/v1/personas/&lt;persona-id&gt; \\\n  -H \"Authorization: Bearer &lt;user-token&gt;\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"status\": \"active\"}'\n</code></pre></p> </li> <li> <p>Update temporal validity:    <pre><code>curl -X PUT https://persona-api/v1/personas/&lt;persona-id&gt; \\\n  -H \"Authorization: Bearer &lt;user-token&gt;\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"valid_from\": \"2024-01-01T00:00:00Z\",\n    \"valid_till\": \"2027-12-31T23:59:59Z\"\n  }'\n</code></pre></p> </li> </ol>"},{"location":"development/personas/#firestore-index-missing","title":"Firestore Index Missing","text":"<p>Symptom: User-profile-api returns 500 error: \"The query requires an index\"</p> <p>Resolution: Create the required composite indexes (see \"Storage Backends\" section above)</p>"},{"location":"development/personas/#service-account-authorization-failure","title":"Service Account Authorization Failure","text":"<p>Symptom: User-profile-api returns 403: \"Forbidden: Service account required\"</p> <p>Causes:</p> <ol> <li>Service token doesn't have <code>client_id=flowpilot-agent</code> (Keycloak)</li> <li>Service token doesn't have <code>gserviceaccount.com</code> in email (GCP)</li> </ol> <p>Resolution:</p> <ul> <li>Local: Use correct Keycloak service account credentials</li> <li>GCP: Ensure authz-api uses GCP identity tokens from metadata server</li> </ul>"},{"location":"development/personas/#configuration-management","title":"Configuration Management","text":""},{"location":"development/personas/#persona-configuration-in-policy-manifest","title":"Persona Configuration in Policy Manifest","text":"<p>Persona configuration is centrally managed in the policy manifest to ensure consistency between authorization policies and profile management.</p> <p>File: <code>infra/opa/policies/travel/manifest.yaml</code></p>"},{"location":"development/personas/#adding-new-persona-titles","title":"Adding New Persona Titles","text":"<p>To add a new persona title:</p> <ol> <li> <p>Update the policy manifest (<code>infra/opa/policies/travel/manifest.yaml</code>):    <pre><code>persona_config:\n  persona_titles:\n    - title: traveler\n      description: \"End user traveling\"\n      can-be-invited: true\n      can-be-delegated-to: false\n      allowed-actions: [read, update]\n\n    - title: new-persona-title  # Add here\n      description: \"Description of new persona\"\n      can-be-invited: false\n      can-be-delegated-to: true\n      allowed-actions: [read, execute]\n</code></pre></p> </li> <li> <p>Update OPA policies if the persona requires special authorization logic</p> </li> <li> <p>Regenerate OPA configuration (for local development):    <pre><code>make generate-opa-config\n# This generates persona_config.json from manifest.yaml\n</code></pre></p> </li> <li> <p>Restart services to load new configuration:    <pre><code># Local\ndocker compose restart flowpilot-persona-api opa\n\n# GCP (auto-generates during build)\n./bin/deploy-all-services.sh\n</code></pre></p> </li> </ol>"},{"location":"development/personas/#adding-new-persona-statuses","title":"Adding New Persona Statuses","text":"<p>To add a new persona status value:</p> <ol> <li> <p>Update the policy manifest:    <pre><code>persona_config:\n  persona_statuses:\n    - pending\n    - active\n    - inactive\n    - suspended\n    - revoked\n    - new-status  # Add here\n</code></pre></p> </li> <li> <p>Update OPA policies if the status requires special handling</p> </li> <li> <p>Regenerate OPA configuration and restart services (same as above)</p> </li> </ol>"},{"location":"development/personas/#best-practices","title":"Best Practices","text":"<ol> <li>Use descriptive persona titles - Match business roles, not technical identities</li> <li>Define all configuration in manifest - Persona titles, statuses, and attributes are defined in <code>manifest.yaml</code> (single source of truth)</li> <li>Regenerate OPA config after manifest changes - Run <code>make generate-opa-config</code> locally after editing manifest</li> <li>Never edit <code>persona_config.json</code> directly - It's auto-generated from manifest.yaml</li> <li>Set reasonable autobook limits - Start conservative, adjust based on user comfort</li> <li>Validate temporal ranges - Ensure valid_till is far enough in the future</li> <li>Use descriptive status values - The lifecycle should be clear: pending \u2192 active \u2192 suspended/inactive/revoked</li> <li>Monitor persona status - Implement workflows to revoked/suspend personas when needed</li> <li>Limit personas per user - Most users should have 1-2 personas (configurable via <code>MAX_PERSONAS_PER_USER</code>)</li> <li>Test delegation with personas - Verify agent personas work correctly with delegations</li> <li>Use active personas for authorization - Inactive/suspended personas should not be used in authorization</li> <li>Provision test data properly - Use seed scripts to maintain consistency across environments</li> <li>Keep manifest in version control - Track all changes to persona configuration</li> <li>Handle duplicate creation errors gracefully - The API enforces uniqueness by failing duplicate creates with HTTP 400; client code should check for existence first or catch and handle duplicate errors appropriately</li> <li>Implement idempotency in provisioning scripts - Seed scripts catch duplicate creation errors and verify existing state matches desired state, allowing safe re-provisioning</li> </ol>"},{"location":"development/personas/#related-documentation","title":"Related Documentation","text":"<ul> <li>Policy Development Guide - How OPA policies use persona data</li> <li>Authorization Architecture - Overall authorization flow</li> <li>API Reference: Persona API - Full API specification</li> </ul>"},{"location":"development/policies-governance/","title":"Policy Governance","text":"<p>This section describes FlowPilot's policy governance framework - how authorization policies are developed, validated, deployed, and audited in a production environment.</p> <p>FlowPilot demonstrates a GitOps-based policy governance model where:</p> <ol> <li>Policies are code - OPA Rego policies live in version control</li> <li>Changes are auditable - Every policy change has a git commit hash</li> <li>Deployments are validated - Automated tests prevent broken policies from reaching production</li> <li>Rollbacks are instant - Zero-downtime rollback to previous policy versions</li> <li>History is preserved - Complete audit trail of all policy deployments</li> </ol>"},{"location":"development/policies-governance/#policy-deployment-lifecycle","title":"Policy Deployment Lifecycle","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 1. Development  \u2502  Developer edits policy.rego\n\u2502                 \u2502  Policy is validated locally\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n         \u2502\n         \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 2. Version      \u2502  Changes committed to git\n\u2502    Control      \u2502  Commit hash becomes version tag\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n         \u2502\n         \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 3. Governance   \u2502  Pre-deployment checks:\n\u2502    Checks       \u2502  \u2022 Syntax validation\n\u2502                 \u2502  \u2022 Unit tests (if present)\n\u2502                 \u2502  \u2022 Uncommitted changes check\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n         \u2502\n         \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 4. Build        \u2502  Docker image built with policy\n\u2502                 \u2502  Tagged with git commit hash\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n         \u2502\n         \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 5. Deploy       \u2502  New revision deployed (no traffic)\n\u2502    (No Traffic) \u2502  Previous revision still serves all traffic\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n         \u2502\n         \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 6. Traffic      \u2502  100% traffic shifted to new revision\n\u2502    Shift        \u2502  Zero-downtime cutover\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n         \u2502\n         \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 7. Regression   \u2502  Full test suite runs against new policy\n\u2502    Tests        \u2502  12 authorization scenarios validated\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n         \u2502\n         \u251c\u2500 PASS \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n         \u2502                     \u2502\n         \u2502                     \u25bc\n         \u2502            \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n         \u2502            \u2502 8. Success      \u2502  Deployment complete\n         \u2502            \u2502                 \u2502  Audit log updated\n         \u2502            \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n         \u2502\n         \u2514\u2500 FAIL \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                               \u2502\n                               \u25bc\n                      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                      \u2502 8. Auto-Rollback\u2502  Traffic shifted back\n                      \u2502                 \u2502  Previous policy restored\n                      \u2502                 \u2502  Incident logged\n                      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"development/policies-governance/#deployment-script","title":"Deployment Script","text":""},{"location":"development/policies-governance/#usage","title":"Usage","text":"<pre><code># Standard deployment (with all checks and tests)\n./bin/deploy-opa-policy.sh\n\n# Skip regression tests (faster, less safe)\n./bin/deploy-opa-policy.sh --skip-tests\n\n# Automated deployment (no prompts)\n./bin/deploy-opa-policy.sh --auto-approve\n\n# Combined flags\n./bin/deploy-opa-policy.sh --skip-tests --auto-approve\n</code></pre>"},{"location":"development/policies-governance/#what-the-script-does","title":"What the Script Does","text":"<p>Governance Checks</p> <ul> <li>Validates all Rego files have correct syntax</li> <li>Warns if uncommitted changes exist (policies MUST be version controlled)</li> <li>Runs OPA unit tests if present</li> </ul> <p>Version Tagging</p> <ul> <li>Uses git commit hash as version identifier (e.g., <code>a3f9d2c</code>)</li> <li>Tags Docker image with version for traceability</li> <li>Creates Cloud Run revision tag for easy access</li> </ul> <p>Safe Deployment</p> <ul> <li>Deploys new revision without routing traffic (no user impact)</li> <li>Shifts traffic only after successful deployment</li> <li>Monitors for errors during traffic shift</li> </ul> <p>Automated Testing</p> <ul> <li>Runs 12 regression tests covering all authorization scenarios</li> <li>Tests delegation, personas, autobook constraints, anti-spoofing</li> <li>Validates new policy behavior matches expectations</li> </ul> <p>Automatic Rollback</p> <ul> <li>If tests fail, immediately restores previous policy</li> <li>No manual intervention needed for failed deployments</li> <li>Complete rollback in &lt;10 seconds</li> </ul> <p>Audit Trail</p> <ul> <li>Logs every deployment attempt to <code>logs/opa-deployments.log</code></li> <li>Records: timestamp, version, outcome, rollback events</li> <li>Shows recent deployment history at end of each deployment</li> </ul>"},{"location":"development/policies-governance/#governance-controls","title":"Governance Controls","text":""},{"location":"development/policies-governance/#pre-deployment-controls","title":"Pre-Deployment Controls","text":"<p>Version Control Requirement</p> <ul> <li>All policy changes must be committed to git before deployment</li> <li>Uncommitted changes trigger a warning and require confirmation</li> <li>Ensures every production policy has a commit hash for traceability</li> </ul> <p>Syntax Validation</p> <ul> <li>OPA CLI validates all Rego files before deployment</li> <li>Prevents syntax errors from reaching production</li> <li>Fails fast if policies have parse errors</li> </ul> <p>Unit Testing (optional but recommended)</p> <ul> <li>If <code>policy_test.rego</code> files exist, they are automatically run</li> <li>Tests validate policy logic before deployment</li> <li>Example: Test that suspended personas are always denied</li> </ul>"},{"location":"development/policies-governance/#deployment-controls","title":"Deployment Controls","text":"<p>Zero-Downtime Deployment</p> <ul> <li>New policy revision deployed alongside old revision</li> <li>Traffic shifted only after new revision is healthy</li> <li>No service interruption during policy updates</li> </ul> <p>Canary Testing</p> <ul> <li>Script supports gradual traffic shifting (easily extensible)</li> <li>Could deploy to 10% traffic, validate metrics, then 100%</li> <li>Reduces blast radius of policy errors</li> </ul>"},{"location":"development/policies-governance/#post-deployment-controls","title":"Post-Deployment Controls","text":"<p>Automated Regression Testing</p> <ul> <li>12 comprehensive test scenarios run automatically</li> <li>Covers positive and negative authorization cases</li> <li>Tests run against production environment (GCP Cloud Run)</li> </ul> <p>Automatic Rollback</p> <ul> <li>Failed tests trigger immediate rollback</li> <li>Previous policy restored within seconds</li> <li>No human intervention required</li> </ul> <p>Audit Logging</p> <ul> <li>Every deployment logged with:<ul> <li>Timestamp (UTC)</li> <li>Version tag (git commit hash)</li> <li>Outcome (success/failure/rollback)</li> <li>Revision identifier</li> </ul> </li> <li>Immutable audit trail for compliance</li> </ul>"},{"location":"development/policies-governance/#governance-best-practices","title":"Governance Best Practices","text":""},{"location":"development/policies-governance/#for-policy-authors","title":"For Policy Authors","text":"<p>Always commit before deploying <pre><code>git add infra/opa/policies/\ngit commit -m \"policy: add persona validity time checks\"\n./bin/deploy-opa-policy.sh\n</code></pre></p> <p>Write unit tests for complex logic <pre><code># infra/opa/policies/travel/policy_test.rego\ntest_suspended_persona_denied {\n  not allow with input as {\n    \"resource\": {\"properties\": {\"owner\": {\"persona_status\": \"suspended\"}}},\n    # ... rest of input\n  }\n}\n</code></pre></p> <p>Test locally before deploying <pre><code>opa check infra/opa/policies --strict\nopa test infra/opa/policies -v\n</code></pre></p> <p>Use descriptive commit messages    - Good: <code>policy: require active persona status, remove backward compat</code>    - Bad: <code>update policy</code></p>"},{"location":"development/policies-governance/#for-operations-teams","title":"For Operations Teams","text":"<p>Monitor the audit log <pre><code>tail -f logs/opa-deployments.log\n</code></pre></p> <p>Integrate with CI/CD    - Run <code>deploy-opa-policy.sh --auto-approve</code> in CI pipeline    - Trigger on merge to <code>main</code> branch    - Alert on failures</p> <p>Set up alerting    - Alert on rollback events    - Alert on repeated deployment failures    - Monitor Cloud Run revision health</p> <p>Review audit trail regularly <pre><code># Show all deployments in last 7 days\ngrep \"$(date -v-7d +%Y-%m-%d)\" logs/opa-deployments.log\n\n# Show all rollbacks\ngrep \"ROLLBACK\" logs/opa-deployments.log\n</code></pre></p>"},{"location":"development/policies-governance/#for-compliancesecurity-teams","title":"For Compliance/Security Teams","text":"<p>Policy changes are traceable</p> <ul> <li>Every production policy has a git commit hash</li> <li><code>git log infra/opa/policies/</code> shows complete change history</li> <li><code>git blame</code> shows who changed what and when</li> </ul> <p>Deployments are audited</p> <ul> <li>Complete audit trail in <code>logs/opa-deployments.log</code></li> <li>Includes: who deployed (via git author), when, what version</li> <li>Rollback events are logged with reason</li> </ul> <p>Failed deployments can't reach production</p> <ul> <li>Syntax errors caught pre-deployment</li> <li>Behavioral regressions caught by automated tests</li> <li>Automatic rollback prevents broken policies from staying live</li> </ul> <p>Rollback capability is tested</p> <ul> <li>Every deployment validates rollback works (via failed test scenario)</li> <li>Previous policy versions are retained in Cloud Run</li> <li>Instant rollback without code changes</li> </ul>"},{"location":"development/policies-governance/#example-deployment-session","title":"Example Deployment Session","text":"<pre><code>$ ./bin/deploy-opa-policy.sh\n\n\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n  OPA Policy Deployment with Governance\n\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n\u2139 Running governance checks...\n\u2139 Validating Rego syntax...\n\u2713 Syntax validation passed\n\u2713 Governance checks passed\n\u2139 Current active revision: flowpilot-opa-00009-gc5\n\u2139 New version tag: b7f8a3c\n\nProceed with deployment? (y/N) y\n\n\u2139 Building OPA container (version: b7f8a3c)...\n\u2713 Build completed successfully\n\u2713 Image tagged: b7f8a3c\n\u2139 Deploying new revision (no traffic)...\n\u2713 Revision deployed (no traffic)\n\u2139 New revision: flowpilot-opa-00010-xj2\n\u2139 Shifting 100% traffic to flowpilot-opa-00010-xj2...\n\u2713 Traffic shifted to flowpilot-opa-00010-xj2\n\n\u2139 Waiting 5 seconds for service to stabilize...\n\u2139 Running regression tests against deployed service...\n======================================================================\nFlowPilot Regression Test Suite - Firebase/Cloud Run\n======================================================================\n[... 12 tests run ...]\n\u2713 All regression tests passed\n\n\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\u2713 Deployment successful!\n\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\nVersion:          b7f8a3c\nRevision:         flowpilot-opa-00010-xj2\nPrevious:         flowpilot-opa-00009-gc5\nService URL:      https://flowpilot-opa-737191827545.us-central1.run.app\n\nTagged URL:       https://vb7f8a3c---flowpilot-opa-737191827545.us-central1.run.app\n\nRecent deployment history (last 5):\n  [2026-01-15T11:20:15Z] DEPLOY_START: Deploying version a3f9d2c\n  [2026-01-15T11:20:45Z] DEPLOY_SUCCESS: Version a3f9d2c deployed as flowpilot-opa-00009-gc5\n  [2026-01-15T11:35:12Z] DEPLOY_START: Deploying version b7f8a3c\n  [2026-01-15T11:36:02Z] DEPLOY_SUCCESS: Version b7f8a3c deployed as flowpilot-opa-00010-xj2\n\nTo rollback if needed:\n  gcloud run services update-traffic flowpilot-opa \\\n    --region=us-central1 \\\n    --to-revisions=flowpilot-opa-00009-gc5=100\n</code></pre>"},{"location":"development/policies-governance/#extending-the-governance-controls","title":"Extending the Governance Controls","text":""},{"location":"development/policies-governance/#adding-manual-approval-gate","title":"Adding Manual Approval Gate","text":"<p>For production environments, add a manual approval step:</p> <pre><code># 1. Deploy to staging (no traffic)\n./bin/deploy-opa-policy.sh --skip-tests\n\n# 2. Manual testing/review\n\n# 3. Shift traffic after approval\ngcloud run services update-traffic flowpilot-opa \\\n  --region=us-central1 \\\n  --to-revisions=flowpilot-opa-00010-xj2=100\n</code></pre>"},{"location":"development/policies-governance/#adding-slack-notifications","title":"Adding Slack Notifications","text":"<p>Integrate with Slack for deployment notifications:</p> <pre><code># Add to audit_log function\ncurl -X POST $SLACK_WEBHOOK_URL \\\n  -H 'Content-Type: application/json' \\\n  -d \"{\\\"text\\\":\\\"OPA Policy deployed: ${VERSION_TAG}\\\"}\"\n</code></pre>"},{"location":"development/policies-governance/#adding-policy-signing","title":"Adding Policy Signing","text":"<p>Sign policies with GPG for tamper-proof deployments:</p> <pre><code># Before deployment\ngit tag -s \"policy-v${VERSION_TAG}\" -m \"Release ${VERSION_TAG}\"\ngit verify-tag \"policy-v${VERSION_TAG}\"\n</code></pre>"},{"location":"development/policies-governance/#adding-change-approval-workflow","title":"Adding Change Approval Workflow","text":"<p>Require PR approvals before merging policy changes:</p> <pre><code># .github/CODEOWNERS\ninfra/opa/policies/ @security-team @policy-reviewers\n</code></pre>"},{"location":"development/policies-governance/#periodically-review-compliance-artifacts","title":"Periodically Review Compliance Artifacts","text":"<p>The governance framework produces these compliance artifacts:</p> <p>Audit Log (<code>logs/opa-deployments.log</code>) - Immutable record of all deployments - Includes timestamps, versions, outcomes</p> <p>Git History (<code>git log infra/opa/policies/</code>) - Complete change history - Author, timestamp, rationale (commit message)</p> <p>Tagged Container Images - Every deployed policy has tagged image - Can redeploy exact historical version</p> <p>Test Results - Regression test output proves policy behavior - Captures before/after for each deployment</p> <p>Rollback Records - Automatic rollbacks are logged - Shows governance controls prevented bad deployments</p>"},{"location":"development/policies-governance/#summary","title":"Summary","text":"<p>FlowPilot's policy governance demonstrates:</p> <p>\u2705 Version Control - All policies in git with commit hashes \u2705 Pre-Deployment Validation - Syntax checks and unit tests \u2705 Zero-Downtime Deployment - No service interruption \u2705 Automated Testing - 12 scenarios validate policy behavior \u2705 Automatic Rollback - Failed tests trigger instant rollback \u2705 Audit Trail - Complete deployment history logged \u2705 Rollback Capability - Previous versions always available  </p> <p>This governance model ensures authorization policies can be changed safely and confidently in production environments</p>"},{"location":"development/policies/","title":"Policy Development","text":"<p>This guide explains how FlowPilot\u2019s authorization policies are structured, how they are evaluated, and the role of the <code>authz-api</code> in the overall authorization flow.</p> <p>It explains: - How authorization policies are structured and evaluated - How AuthZEN, OPA, and Rego fit together - How policies are developed, tested, deployed, and governed in production</p> <p>FlowPilot uses Open Policy Agent (OPA) with Rego policies to implement declarative access control. At its core, the policy engine answers the question:</p> <p>\u201cIs this subject allowed to perform this action on this resource?\u201d</p>"},{"location":"development/policies/#policy-decision-flow","title":"Policy Decision Flow","text":"<p>FlowPilot deliberately separates authorization responsibilities across three layers.</p>"},{"location":"development/policies/#policy-decision-layer-pdp","title":"Policy Decision Layer (PDP)","text":"<ul> <li>Is implemented using OPA</li> <li>Is driven by declarative rules written in Rego</li> <li>Is limited to pure policy logic</li> <li>Performs no data fetching or external calls</li> <li>Receives fully prepared, decision-ready input via AuthZEN</li> </ul>"},{"location":"development/policies/#policy-information-layer-authz-api","title":"Policy Information Layer (Authz-API)","text":"<ul> <li>Acts as the authorization orchestration layer</li> <li>Consolidates data from multiple Policy Information Points (PIPs)</li> <li>Validates and interprets JWT bearer tokens</li> <li>Fetches user profile data (ABAC attributes)</li> <li>Resolves delegation chains (ReBAC attributes)</li> <li>Normalizes, enriches, and hardens all inputs</li> <li>Invokes OPA with a complete and consistent policy context</li> </ul>"},{"location":"development/policies/#policy-enforcement-layer-pep","title":"Policy Enforcement Layer (PEP)","text":"<ul> <li>Submits AuthZEN requests that express intent</li> <li>Applies and enforces decisions returned by the PDP</li> <li>Never evaluates authorization logic locally</li> <li>Must delegate ALL authorization decisions to authz-api/OPA (including owner checks)</li> </ul> <p>PEPs in the FlowPilot demo: - Agentic AI components (ai-agent-api) - Backend microservices (domain-services-api) - Web app and mobile/desktop app</p> <p>Critical PEP Requirement:</p> <p>PEPs MUST NOT contain inline authorization logic such as: <pre><code># \u274c WRONG - PEP making policy decisions\nif condition1 and condition2:\n    # Proceed with action\n</code></pre></p> <p>Instead, ALL authorization requests must go through authz-api: <pre><code># \u2713 CORRECT - PEP delegates to PDP\nresponse = requests.post(f\"{AUTHZ_API}/v1/evaluate\", json=authzen_request)\nif response.json()[\"decision\"] == \"allow\":\n    # Proceed with action\n</code></pre></p> <p>This ensures: - Single source of truth for all policy decisions - Consistent policy enforcement across all services - Complete audit trail of authorization decisions - Policy changes don't require code changes in PEPs</p> <p>This separation ensures that:</p> <ul> <li>Policies remain clean, declarative, and testable</li> <li>Authorization logic is centralized and auditable</li> <li>Application services stay simple and focused on business behavior</li> </ul>"},{"location":"development/policies/#notes-on-opa-and-rego","title":"Notes on OPA and Rego","text":"<p>OPA is a CNCF Graduated project (graduated January 29, 2021), which signals maturity, governance, and production readiness. However, it is not a formal international standard.</p> <ul> <li>OPA is open source and published under the Apache License 2.0</li> <li>Rego, the policy language used by OPA, is likewise not a formal standard</li> <li>The authoritative definition of Rego semantics and behavior is provided by the OPA project itself:</li> <li>The OPA documentation serves as the canonical language reference</li> <li>Built-in functions are defined, versioned, and maintained by OPA</li> </ul> <p>In practice, this means Rego policies are portable across OPA deployments, while remaining tightly aligned with the OPA project\u2019s evolution.</p>"},{"location":"development/policies/#policy-architecture","title":"Policy Architecture","text":"<p>FlowPilot supports multiple policies with dynamic selection based on resource type or explicit hints. Each policy is a self-contained package with:</p> <ul> <li>Rego policy file - Decision logic (e.g., <code>policy.rego</code>)</li> <li>Manifest file - Metadata, attributes, and configuration (<code>manifest.yaml</code>)</li> </ul>"},{"location":"development/policies/#policy-directory-structure","title":"Policy Directory Structure","text":"<pre><code>infra/opa/policies/\n\u251c\u2500\u2500 travel/\n\u2502   \u251c\u2500\u2500 manifest.yaml    # Travel policy configuration\n\u2502   \u2514\u2500\u2500 policy.rego      # Travel booking rules (package: auto_book)\n\u2514\u2500\u2500 nursing/\n    \u251c\u2500\u2500 manifest.yaml    # Nursing policy configuration\n    \u2514\u2500\u2500 policy.rego      # Nursing care rules (package: nursing_care)\n</code></pre>"},{"location":"development/policies/#policy-manifest","title":"Policy Manifest","text":"<p>Each policy has a <code>manifest.yaml</code> that defines:</p> <pre><code>name: travel\npackage: auto_book\n</code></pre> <p>Manifest Fields:</p> <ul> <li><code>name</code> - Policy identifier (must match directory name)</li> <li><code>package</code> - OPA Rego package name</li> </ul> <p>Additionally, the manifest also defines the attributes of personas that are needed to take authorization decisions (see Personas Guide).</p>"},{"location":"development/policies/#policy-selection","title":"Policy Selection","text":"<p>The authz-api uses a PolicyRegistry to manage multiple policies and select the appropriate one per request.</p> <p>Policy Selection:</p> <ul> <li>context.policy_hint - Explicit policy name (REQUIRED)</li> <li>PEPs must always specify which policy to use</li> <li>No automatic policy selection or fallback</li> </ul> <p>Example Request:</p> <pre><code>{\n  \"subject\": {\"id\": \"user-123\"},\n  \"action\": {\"name\": \"execute\"},\n  \"resource\": {\n    \"type\": \"workflow_item\"\n  },\n  \"context\": {\n    \"policy_hint\": \"travel\"  // REQUIRED\n  }\n}\n</code></pre> <p>Policy Loading:</p> <p>The authz-api loads all policies at startup:</p> <pre><code>Loaded 2 policies: travel, nursing\n</code></pre>"},{"location":"development/policies/#attribute-defaults-and-validation","title":"Attribute Defaults and Validation","text":"<p>The authz-api applies defaults and validates attributes before calling OPA:</p> <p>Default Application:</p> <ol> <li>Fetch persona from persona-api</li> <li>Apply defaults for missing persona attributes</li> <li>Extract resource attributes from request</li> <li>Apply defaults for missing resource attributes</li> <li>Pass complete attribute set to OPA</li> </ol> <p>Validation:</p> <ol> <li>Check all required attributes are present</li> <li>If validation fails, return structured error:</li> </ol> <pre><code>{\n  \"decision\": \"deny\",\n  \"reason_codes\": [\"authz.missing_required_attributes\"],\n  \"advice\": [{\"message\": \"Missing required resource attributes: departure_date\"}]\n}\n</code></pre>"},{"location":"development/policies/#policy-construction","title":"Policy Construction","text":""},{"location":"development/policies/#decision-framework","title":"Decision framework","text":"<p>Allowed actions are specified as follows:</p> <ul> <li><code>execute</code> - Execute workflow items (book travel)</li> <li><code>update</code> - Update workflow items</li> <li><code>delete</code> - Delete workflow items</li> <li><code>read</code> - View workflows (read-only access)</li> <li><code>validate_persona</code> - Validate persona status and validity (used by UI/web-app)</li> </ul> <p><pre><code>default allow := false\n</code></pre> This means a fail-closed by default, so the decision is <code>deny</code> unless explicitly allowed.</p> <p>Decision routing is specified as follows:</p> <p><pre><code>allow if {\n  input.action.name == \"execute\"\n  allow_execute\n}\nallow if {\n  input.action.name == \"read\"\n  allow_read\n}\nallow if {\n  input.action.name == \"update\"\n  allow_update\n}\nallow if {\n  input.action.name == \"delete\"\n  allow_delete\n}\nallow if {\n  input.action.name == \"validate_persona\"\n  allow_validate_persona\n}\n</code></pre> This routes the decision to different rule sets depending on the requested action: - <code>execute</code>, <code>update</code>, <code>delete</code> require full authorization gates - <code>read</code> has simpler requirements (no ABAC checks) - <code>validate_persona</code> validates persona status without requiring a workflow/resource</p> <p>Decisions Gates are specified as follows:</p> <pre><code>allow_execute if {\n  authorized_principal # Anti-spoofing and delegation check\n  appropriate_persona  # Persona type check (agent vs owner personas)\n  valid_persona        # Persona must be active and within valid time range\n  has_consent          # User consent\n  acceptable_risk      # Risk threshold\n  within_cost_limit    # Cost ceiling\n  sufficient_advance   # Lead time requirement\n}\n</code></pre> <p>This defines 7 gates that all must pass before the decision is <code>allow</code> - Each gate is a separate rule evaluated independently - If any gate fails, <code>allow_execute</code> is false</p> <p>Authz-API role: Interprets <code>allow = false</code> as a deny decision. It also includes <code>action.name</code> in the OPA input based on the PEP's request. Provides all data needed for gate evaluation (more below)</p>"},{"location":"development/policies/#anti-spoofing-checks","title":"Anti-Spoofing Checks","text":"<pre><code>authorized_principal if {\n  # Any authenticated principal (user with valid token) can attempt to create\n  input.action.name == \"create\"\n  principal_id := input.context.principal.id\n  principal_id != \"\"\n}\n\nauthorized_principal if {\n  # Owner accessing their own resource (directly or via agent)\n  principal_id := input.context.principal.id\n  owner_id := input.resource.properties.owner.id\n  principal_id == owner_id\n}\n\nauthorized_principal if {\n  # Valid delegation: any subject (regular user or ai-agent) with delegation\n  # If the action is in delegated_actions, a delegation path must exist\n  input.action.name in input.context.delegation.delegated_actions\n</code></pre> <p>What this does:</p> <ul> <li>Prevents principal spoofing (acting as someone else without permission)</li> <li>Allows 2 scenarios:</li> <li>Owner access - Principal is the owner (covers both direct user access and agent activated by owner)</li> <li>Delegated access - Valid delegation chain exists with required action permissions</li> </ul> <p>Authz-API role:</p> <ul> <li>Queries delegation-api to get delegation information</li> <li>Includes <code>context.delegation.delegated_actions</code> array (empty if no delegation exists)</li> <li>Includes <code>context.delegation.delegation_chain</code> (empty if no delegation exists)</li> <li>Note: <code>delegation.valid</code> field is NOT sent to OPA - it's redundant since <code>delegated_actions</code> is empty when no valid path exists</li> <li>Ensures <code>context.principal</code> is always present:</li> <li>If provided in request: uses the provided principal (delegated scenario)</li> <li>If not provided: creates principal from owner information (agent acting for owner)</li> <li>Enriches <code>context.principal</code> with persona metadata (status, validity timestamps, attributes)</li> </ul>"},{"location":"development/policies/#appropriate-persona-for-delegation","title":"Appropriate Persona for Delegation","text":"<pre><code>delegation_personas := {\"ai-agent\", \"domain-services\", \"travel-agent\", \"office-manager\", \"booking-assistant\"}\n\nvalid_delegation_personas_for_action contains persona if {\n  # Delegation personas can execute/update/delete on behalf of owner\n  action := input.action.name\n  action in [\"execute\", \"update\", \"delete\"]\n  persona := delegation_personas[action][_]\n}\n\nvalid_delegation_personas_for_action contains persona if {\n  # Service personas are always valid for execute/update/delete actions\n  # Both 'ai-agent' and 'domain-services' are treated as equivalent service personas\n  action := input.action.name\n  action in [\"execute\", \"update\", \"delete\"]\n  persona := {\"ai-agent\", \"domain-services\"}[_]\n}\n\nappropriate_persona_for_action if {\n  # For create actions, there's no existing resource/owner to compare against\n  # Just verify the principal has selected a persona\n  input.action.name == \"create\"\n  principal_persona := input.context.principal.persona\n  principal_persona != \"\"\n}\n\nappropriate_persona_for_action if {\n  # If acting on behalf of someone else (via delegation), must use a delegation persona\n  principal_id := input.context.principal.id\n  owner_id := input.resource.properties.owner.id\n  principal_id != owner_id\n  principal_persona := input.context.principal.persona\n  principal_persona != \"\"\n  valid_delegation_personas_for_action[principal_persona]\n}\n\nappropriate_persona_for_action if {\n  # If acting as owner, must use the same owner's persona\n  principal_id := input.context.principal.id\n  owner_id := input.resource.properties.owner.id\n  principal_id == owner_id\n  owner_persona := input.resource.properties.owner.persona\n  principal_persona := input.context.principal.persona\n  principal_persona == owner_persona\n  principal_persona != \"\"\n}\n</code></pre> <p>What this does:</p> <ul> <li>Validates that the user's business role (persona) is appropriate for the action</li> <li>Delegated users must have agent personas (<code>travel-agent</code>, etc.)</li> <li>Owners must match their own persona</li> <li>This checks the type of persona, not its validity status or time range</li> </ul> <p>Authz-API role:</p> <ul> <li>Extracts <code>persona</code> from JWT custom claims</li> <li>Fetches complete persona object from persona-api (includes autobook attributes, status, validity)</li> <li>Includes both <code>subject.properties.persona</code> and enriched <code>owner</code> object in OPA input</li> </ul> <p>Important: The <code>owner.persona</code> field contains the persona title (e.g., \"traveler\"), while the full persona data (with autobook attributes, status, and temporal validity) is fetched from persona-api and merged into <code>resource.properties.owner</code>. See Personas Guide for more details.</p>"},{"location":"development/policies/#read-authorization","title":"Read Authorization","text":"<p>Read access follows simpler authorization rules compared to execute actions. The persona used for reading doesn't matter - if you have delegation with 'read' action, you can read. This treats 'delegation' and 'invitation' identically - both are just delegations with 'read' scope. No ABAC checks (cost, risk, lead time) are required - only identity and delegation validation.</p> <pre><code>allow_read if {\n  action_allowed_for_persona  # Persona must have 'read' in allowed-actions\n  # Owner can always read their own workflows\n  principal_id := input.context.principal.id\n  owner_id := input.resource.properties.owner.id\n  principal_id == owner_id\n}\n\nallow_read if {\n  action_allowed_for_persona  # Persona must have 'read' in allowed-actions\n  # Anyone with a delegation chain containing 'read' action can read\n  principal_id := input.context.principal.id\n  owner_id := input.resource.properties.owner.id\n  principal_id != owner_id\n  input.action.name in input.context.delegation.delegated_actions\n}\n</code></pre> <p>What this does:</p> <ul> <li>Owner access: Resource owner can always read their own resources</li> <li>Delegation required: Non-owners MUST have explicit delegation with read permission</li> <li>Persona validation: Delegated readers must have appropriate persona (agent or invitation personas)</li> <li>No ABAC checks: Read actions skip consent, cost, risk, and lead time checks</li> <li>AI-agent support: AI agents can read when acting as owner or with delegation</li> </ul> <p>Key Differences from Execute:</p> <ul> <li>No <code>has_consent</code> check (consent only applies to autonomous execution)</li> <li>No <code>within_cost_limit</code>, <code>acceptable_risk</code>, or <code>sufficient_advance</code> checks</li> <li>Simpler persona requirements (agent personas OR invitation personas)</li> <li>Still requires delegation for non-owners</li> </ul> <p>Authz-API role:</p> <ul> <li>Validates delegation chain for non-owner reads</li> <li>No persona attribute fetching needed (only persona title required)</li> <li>Returns structured deny with reason codes if validation fails</li> </ul> <p>Security Note:</p> <p>Prior versions of the policy incorrectly allowed read access based on matching persona alone (without delegation). This vulnerability was fixed to require explicit delegation for all non-owner access. Matching persona is now only used as additional validation after delegation is confirmed, not as a bypass mechanism.</p>"},{"location":"development/policies/#persona-validation-action","title":"Persona Validation Action","text":"<p>The policy supports a special <code>validate_persona</code> action that allows the web-app (PEP) to validate persona status without requiring a workflow or resource. This is used to display warnings when users have invalid personas.</p> <pre><code>allow_validate_persona if {\n  # Principal must have a persona specified\n  principal_persona := input.context.principal.persona\n  principal_persona != \"\"\n\n  # Persona must be active and within valid time range\n  valid_persona\n}\n</code></pre> <p>What this does:</p> <ul> <li>Validates persona without requiring workflow/resource context</li> <li>Checks <code>valid_persona</code> rule (status + temporal validity)</li> <li>Used by web-app to show warnings for invalid personas</li> <li>Enables proactive user feedback before attempting operations</li> </ul> <p>Use Case:</p> <p>When a user creates their first persona with status=<code>inactive</code> or with dates outside the current time range, the web-app validates it via authz-api and displays a blue warning box:</p> <p>\u26a0\ufe0f Your persona \"traveler\" is not currently valid. Without a valid active persona, you cannot create workflows or perform any operations. Please activate this persona or create a new active one.</p> <p>Authz-API role:</p> <ul> <li>Accepts <code>resource.type=\"persona\"</code> in policy selection</li> <li>No owner or workflow attributes required</li> <li>Only validates persona attributes in <code>context.principal</code></li> </ul>"},{"location":"development/policies/#persona-validity-check","title":"Persona Validity Check","text":"<p>In addition to checking the persona type is appropriate, the policy enforces that the acting principal's persona is currently valid. This combines status and temporal checks:</p> <pre><code>valid_persona if {\n  input.context.principal.persona_status == \"active\"\n  valid_from := time.parse_rfc3339_ns(input.context.principal.persona_valid_from)\n  valid_till := time.parse_rfc3339_ns(input.context.principal.persona_valid_till)\n  now := time.now_ns()\n  now &gt;= valid_from\n  now &lt;= valid_till\n}\n</code></pre> <p>This rule ensures:</p> <ol> <li>Status is <code>active</code> - Persona is not suspended, inactive, or expired</li> <li>Within time range - Current time is between <code>valid_from</code> and <code>valid_till</code></li> </ol> <p>Possible persona statuses:</p> <ul> <li><code>active</code> - Normal operational state (only valid status)</li> <li><code>pending</code> - Persona assignment is pending approval</li> <li><code>inactive</code> - Disabled by user</li> <li><code>suspended</code> - Temporarily disabled  </li> <li><code>revoked</code> - Disabled by user-admin</li> </ul> <p>Use cases:</p> <ul> <li>Time-limited personas (temporary roles, seasonal access)</li> <li>Trial periods with automatic expiration</li> <li>Future-dated persona activation</li> </ul> <p>Authz-API role for persona attributes:</p> <ul> <li>Fetches owner persona from persona-api</li> <li>Extracts: <code>persona_status</code>, <code>valid_from</code>, <code>valid_till</code>, and all <code>autobook_*</code> fields</li> <li>Merges into <code>resource.properties.owner</code> for OPA evaluation</li> <li>Fetches principal persona (if principal \u2260 owner or no principal provided)</li> <li>Enriches <code>context.principal</code> with persona validity metadata:</li> <li><code>persona_status</code>, <code>persona_valid_from</code>, <code>persona_valid_till</code></li> <li>Policy-specific attributes (when applicable)</li> <li>When no principal provided in request: creates <code>context.principal</code> from owner data</li> </ul>"},{"location":"development/policies/#user-consent-check","title":"User Consent Check","text":"<pre><code>has_consent if {\n  input.resource.properties.owner.autobook_consent == true\n}\n</code></pre> <p>What this does:</p> <ul> <li>Requires explicit user opt-in for autonomous booking</li> <li>Consent is per-user, not per-workflow</li> </ul> <p>Authz-API role:</p> <ul> <li>Fetches persona from persona-api</li> <li>Extracts <code>autobook_consent</code> boolean from persona record</li> <li>Includes in <code>resource.properties.owner.autobook_consent</code></li> </ul> <p>Important: Autobook consent is per-persona, not per-user. A user with multiple personas can have different consent settings for each.</p>"},{"location":"development/policies/#user-preferences-check","title":"User Preferences Check","text":"<p>A user can set constraits to the AI-agent about when it can act autonomously.</p> <p>In the use case of \"travel\", this reflects the risk a traveler is willing to take in terms of cost, transport risk, and time to change their mind.</p> <pre><code>within_cost_limit if {\n  # Skip if planned_price is absent\n  not \"planned_price\" in object.keys(input.resource.properties)\n}\n\nwithin_cost_limit if {\n  \"planned_price\" in object.keys(input.resource.properties)\n  planned_price := input.resource.properties.planned_price\n  max_cost := input.resource.properties.owner.autobook_price\n  planned_price &lt;= max_cost\n}\n\nacceptable_risk if {\n  # Skip if airline_risk_score is absent\n  not \"airline_risk_score\" in object.keys(input.resource.properties)\n}\n\nacceptable_risk if {\n  \"airline_risk_score\" in object.keys(input.resource.properties)\n  risk := input.resource.properties.airline_risk_score\n  max_risk := input.resource.properties.owner.autobook_risklevel\n  risk &lt;= max_risk\n}\n\nsufficient_advance if {\n  departure_date_str := input.resource.properties.departure_date\n  departure_date := time.parse_rfc3339_ns(departure_date_str)\n  now := time.now_ns()\n  delta_days := (departure_date - now) / 1000000000 / 60 / 60 / 24\n  delta_days &gt;= input.resource.properties.owner.autobook_leadtime\n}\n</code></pre> <p>What this does:</p> <ul> <li>Ensures booking cost doesn't exceed user's configured limit</li> <li>Cost limit is per-user preference</li> <li>Checks airline risk score against user's tolerance</li> <li>Allows execution if risk score is missing (optional field)</li> <li>Denies if risk exceeds configured threshold</li> <li>Requires minimum advance notice before departure</li> <li>Prevents last-minute autonomous bookings</li> </ul> <p>Authz-API role:</p> <ul> <li>Extracts <code>planned_price</code> from workflow item resource</li> <li>Fetches <code>autobook_price</code> from user profile</li> <li>Extracts <code>airline_risk_score</code> from workflow item resource, if present</li> <li>Fetches <code>autobook_risklevel</code> from user profile</li> <li>Extracts <code>departure_date</code> from workflow item resource</li> <li>Fetches <code>autobook_leadtime</code> from user profile</li> <li>Converts and normalizes prices, risk scores and times</li> </ul>"},{"location":"development/policies/#deny-reason-codes","title":"Deny Reason Codes","text":"<p>The policy provides a structured reason code for every denial scenario. Reason codes follow the gate evaluation order:</p> <pre><code>reasons[code] if {\n  input.action.name in [\"execute\", \"update\", \"delete\"]\n  not authorized_principal\n  code := \"auto_book.unauthorized_principal\"\n}\nreasons[code] if {\n  input.action.name in [\"execute\", \"update\", \"delete\"]\n  code := \"auto_book.persona_mismatch\"\n  authorized_principal\n  not appropriate_persona_for_action\n}\nreasons[code] if {\n  input.action.name in [\"execute\", \"update\", \"delete\"]\n  code := \"auto_book.persona_invalid\"\n  authorized_principal\n  appropriate_persona_for_action\n  not valid_persona\n}\nreasons[code] if {\n  input.action.name in [\"execute\", \"update\", \"delete\"]\n  code := \"auto_book.no_consent\"\n  authorized_principal\n  not has_consent\n}\nreasons[code] if {\n  input.action.name in [\"execute\", \"update\", \"delete\"]\n  code := \"auto_book.airline_risk_too_high\"\n  authorized_principal\n  has_consent\n  not acceptable_risk\n}\nreasons[code] if {\n  input.action.name in [\"execute\", \"update\", \"delete\"]\n  code := \"auto_book.cost_limit_exceeded\"\n  authorized_principal\n  has_consent\n  acceptable_risk\n  not within_cost_limit\n}\nreasons[code] if {\n  input.action.name in [\"execute\", \"update\", \"delete\"]\n  code := \"auto_book.insufficient_advance_notice\"\n  authorized_principal\n  has_consent\n  acceptable_risk\n  within_cost_limit\n  not sufficient_advance\n}\n</code></pre> <p>Reason Code Categories:</p> Code Description Gate <code>auto_book.principal_spoofing</code> No valid delegation exists Anti-spoofing <code>auto_book.insufficient_delegation_permissions</code> Delegation lacks execute action Anti-spoofing <code>auto_book.persona_mismatch</code> Subject persona type doesn't match requirements Persona type validation <code>auto_book.persona_invalid</code> Persona status not active OR outside validity time range Persona validity <code>auto_book.no_consent</code> Autobook consent is false Consent <code>auto_book.airline_risk_too_high</code> Risk score exceeds threshold Risk gate <code>auto_book.cost_limit_exceeded</code> Price exceeds configured limit Cost gate <code>auto_book.insufficient_advance_notice</code> Departure too soon Lead time gate <p>What this does:</p> <ul> <li>Provides structured reason codes for denials</li> <li>Each failed gate has a corresponding reason</li> <li>Reasons follow gate evaluation order (fail-fast)</li> <li>Supports debugging and audit trails</li> <li>Enables client-side error messages</li> </ul> <p>Authz-API role:</p> <ul> <li>Collects <code>reasons</code> array from OPA response</li> <li>Returns reason codes to PEP for logging/debugging</li> <li>Maps codes to human-readable messages</li> </ul>"},{"location":"development/policies/#data-sources-for-opa-input","title":"Data Sources for OPA Input","text":"Field Source Provider <code>subject.id</code> AuthZEN request PEP <code>subject.properties.persona</code> JWT custom claims Authz-API <code>action.name</code> AuthZEN request PEP <code>resource.id</code> AuthZEN request PEP <code>resource.properties.planned_price</code> Workflow item data PEP <code>resource.properties.departure_date</code> Workflow item data PEP (normalized by authz-api) <code>resource.properties.owner.persona</code> Workflow creation PEP <code>resource.properties.owner.persona_id</code> Persona lookup User-Profile-API (via authz-api) <code>resource.properties.owner.persona_status</code> Persona lookup User-Profile-API (via authz-api) <code>resource.properties.owner.persona_valid_from</code> Persona lookup User-Profile-API (via authz-api) <code>resource.properties.owner.persona_valid_till</code> Persona lookup User-Profile-API (via authz-api) <code>resource.properties.owner.autobook_*</code> Persona lookup User-Profile-API (via authz-api) <code>context.delegation.*</code> Delegation graph Delegation-API (via authz-api) <code>context.principal</code> AuthZEN request or JWT PEP / Authz-API"},{"location":"development/policies/#best-practices","title":"Best Practices","text":""},{"location":"development/policies/#for-policy-manifest-authors","title":"For Policy Manifest Authors","text":"<ol> <li>Descriptive names - Use clear policy and attribute names</li> <li>Conservative defaults - Start with restrictive defaults, relax as needed</li> <li>Document attributes - Provide clear descriptions for each attribute</li> <li>Type appropriately - Use correct types (integer for counts, float for money)</li> <li>Mark required fields - Only make attributes required if truly mandatory</li> <li>Version carefully - Plan for policy evolution (future versioning support)</li> </ol>"},{"location":"development/policies/#for-policy-authors","title":"For Policy Authors","text":"<ol> <li>Fail-closed - Default to deny</li> <li>Explicit rules - Make allow conditions clear</li> <li>Reason codes - Provide debugging information</li> <li>Type safety - Rely on authz-api normalization and defaults</li> </ol>"},{"location":"development/policies/#for-authz-api-developers","title":"For Authz-API Developers","text":"<ol> <li>Normalize data - Convert types before OPA</li> <li>Validate inputs - Ensure required fields exist</li> <li>Enrich completely - Provide all data OPA needs</li> <li>Handle errors - Graceful degradation on PIP failures</li> <li>Log decisions - Audit all authorization outcomes</li> </ol>"},{"location":"development/policies/#for-pep-developers","title":"For PEP Developers","text":"<ol> <li>Minimal requests - Send only intent, not policy data</li> <li>Consistent format - Use AuthZEN structure</li> <li>Include context - Provide principal when subject \u2260 owner</li> <li>Include policy_hint - Always specify which policy to use in context.policy_hint</li> <li>Enforce decisions - Always respect authz-api response</li> </ol>"},{"location":"development/policies/#related-documentation","title":"Related Documentation","text":"<ul> <li>Authorization Architecture - Overall authorization flow</li> <li>Persona Development Guide - How personas are managed</li> <li>API Reference: Authz API - Full API specification</li> </ul>"},{"location":"getting-started/authentication/","title":"Authentication Setup","text":"<p>Learn how to set up Firebase Authentication for your FlowPilot integration.</p>"},{"location":"getting-started/authentication/#overview","title":"Overview","text":"<p>FlowPilot uses Firebase Authentication tokens to identify users. You'll need to:</p> <ol> <li>Create a Firebase project</li> <li>Enable authentication methods</li> <li>Configure your app with Firebase</li> <li>Get ID tokens to pass to FlowPilot APIs</li> </ol>"},{"location":"getting-started/authentication/#coming-soon","title":"Coming Soon","text":"<p>Detailed setup instructions for Firebase Authentication across web, iOS, and Android platforms.</p> <p>For now, see the Integration Guide for quick examples.</p>"},{"location":"getting-started/first-workflow/","title":"Your First Workflow","text":"<p>A step-by-step tutorial to create and execute your first workflow with FlowPilot.</p>"},{"location":"getting-started/first-workflow/#what-youll-build","title":"What You'll Build","text":"<p>In this tutorial, you'll:</p> <ol> <li>Authenticate a user</li> <li>Create a simple workflow</li> <li>Set up delegation to an AI agent</li> <li>Execute the workflow</li> <li>Handle the results</li> </ol>"},{"location":"getting-started/first-workflow/#coming-soon","title":"Coming Soon","text":"<p>Complete tutorial with code samples for web and mobile.</p> <p>For now, see the Integration Guide for a complete working example.</p>"},{"location":"getting-started/integration/","title":"Integration Guide","text":"<p>Add FlowPilot authorization to your web or mobile application.</p>"},{"location":"getting-started/integration/#overview","title":"Overview","text":"<p>FlowPilot is a managed authorization service for demo purposes. It illustrates:</p> <ul> <li>Multi-persona authorization (user as traveler vs. agent vs. admin)</li> <li>Delegation management (user delegates to AI agent or another user)</li> <li>Policy evaluation (consent checks, risk thresholds, custom rules)</li> <li>Audit trails and explainable decisions</li> </ul>"},{"location":"getting-started/integration/#service-endpoints","title":"Service Endpoints","text":"<p>Production API Base URL: <code>https://flowpilot-domain-services-api-737191827545.us-central1.run.app</code></p> <p>All APIs require bearer access tokens.</p>"},{"location":"getting-started/integration/#available-apis","title":"Available APIs","text":"API Purpose Endpoint Domain Services Manage workflows and workflow items <code>/v1/workflows</code> AuthZ Authorization decisions <code>/v1/evaluate</code> Delegation Manage delegations <code>/v1/delegations</code> User Profile User personas and preferences <code>/v1/profile</code> AI Agent Execute workflows via agent <code>/v1/workflow-runs</code>"},{"location":"getting-started/integration/#prerequisites","title":"Prerequisites","text":"<ol> <li>Firebase Project - Sign up at firebase.google.com</li> <li>FlowPilot Account - Contact us to get your project configured</li> <li>User Profile Storage - Set up Firestore to store user personas and preferences</li> </ol>"},{"location":"getting-started/integration/#step-1-authenticate-your-users","title":"Step 1: Authenticate Your Users","text":"<p>FlowPilot uses Firebase Authentication for user identity. Integrate Firebase Auth in your app:</p> Web (JavaScript)iOS (Swift)Android (Kotlin) <pre><code>import { getAuth, signInWithEmailAndPassword } from 'firebase/auth';\n\nconst auth = getAuth();\nconst userCredential = await signInWithEmailAndPassword(\n  auth, \n  email, \n  password\n);\n\n// Get ID token to pass to FlowPilot\nconst idToken = await userCredential.user.getIdToken();\n</code></pre> <pre><code>import FirebaseAuth\n\nAuth.auth().signIn(withEmail: email, password: password) { result, error in\n    guard let user = result?.user else { return }\n\n    user.getIDToken { token, error in\n        // Use token with FlowPilot APIs\n        let idToken = token\n    }\n}\n</code></pre> <pre><code>import com.google.firebase.auth.FirebaseAuth\n\nval auth = FirebaseAuth.getInstance()\nauth.signInWithEmailAndPassword(email, password)\n    .addOnCompleteListener { task -&gt;\n        if (task.isSuccessful) {\n            val user = auth.currentUser\n            user?.getIdToken(true)?.addOnCompleteListener { tokenTask -&gt;\n                val idToken = tokenTask.result?.token\n                // Use token with FlowPilot APIs\n            }\n        }\n    }\n</code></pre>"},{"location":"getting-started/integration/#step-2-manage-user-profiles","title":"Step 2: Manage User Profiles","text":"<p>FlowPilot provides a User Profile API to manage user personas and preferences. No Firebase SDK required.</p>"},{"location":"getting-started/integration/#get-user-profile","title":"Get User Profile","text":"<pre><code>const response = await fetch(\n  'https://flowpilot-persona-api-737191827545.us-central1.run.app/v1/profile',\n  {\n    headers: {\n      'Authorization': `Bearer ${idToken}`\n    }\n  }\n);\n\nconst profile = await response.json();\nconsole.log('User persona:', profile.personas);\n</code></pre>"},{"location":"getting-started/integration/#update-user-profile","title":"Update User Profile","text":"<pre><code>const response = await fetch(\n  'https://flowpilot-persona-api-737191827545.us-central1.run.app/v1/profile',\n  {\n    method: 'PUT',\n    headers: {\n      'Authorization': `Bearer ${idToken}`,\n      'Content-Type': 'application/json'\n    },\n    body: JSON.stringify({\n      personas: [\"traveler\"],\n      autobook_consent: true,\n      autobook_price: 500,\n      autobook_leadtime: 30,\n      autobook_risklevel: 50\n    })\n  }\n);\n\nconst updatedProfile = await response.json();\n</code></pre>"},{"location":"getting-started/integration/#find-users-by-persona","title":"Find Users by Persona","text":"<p>Find delegation candidates (e.g., travel agents):</p> <pre><code>const response = await fetch(\n  'https://flowpilot-persona-api-737191827545.us-central1.run.app/v1/users?persona=travel-agent',\n  {\n    headers: {\n      'Authorization': `Bearer ${idToken}`\n    }\n  }\n);\n\nconst { users } = await response.json();\nconsole.log('Available agents:', users);\n</code></pre>"},{"location":"getting-started/integration/#profile-fields","title":"Profile Fields","text":"Field Type Description <code>sub</code> string User UUID (from Firebase Auth) <code>personas</code> string[] List of personas: <code>[\"traveler\", \"travel-agent\", \"admin\"]</code> <code>autobook_consent</code> boolean Consent for AI agent execution <code>autobook_price</code> number Max price agent can book <code>autobook_leadtime</code> number Max days in advance <code>autobook_risklevel</code> number Risk tolerance (0-100) <p>For more details about personas, see the Personas Guide.</p>"},{"location":"getting-started/integration/#step-3-create-workflows","title":"Step 3: Create Workflows","text":"<p>Call the Domain Services API to create a workflow (e.g., a travel booking):</p> <pre><code>const response = await fetch(\n  'https://flowpilot-domain-services-api-737191827545.us-central1.run.app/v1/workflows',\n  {\n    method: 'POST',\n    headers: {\n      'Authorization': `Bearer ${idToken}`,\n      'Content-Type': 'application/json'\n    },\n    body: JSON.stringify({\n      template_id: 'trip-to-milan',\n      principal_sub: user.uid,\n      start_date: '2026-02-01',\n      persona: 'traveler'\n    })\n  }\n);\n\nconst workflow = await response.json();\nconsole.log('Created workflow:', workflow.workflow_id);\n</code></pre>"},{"location":"getting-started/integration/#step-4-delegate-to-ai-agent","title":"Step 4: Delegate to AI Agent","text":"<p>Allow the AI agent to execute workflows on the user's behalf:</p> <pre><code>const delegationResponse = await fetch(\n  'https://flowpilot-delegation-api-737191827545.us-central1.run.app/v1/delegations',\n  {\n    method: 'POST',\n    headers: {\n      'Authorization': `Bearer ${idToken}`,\n      'Content-Type': 'application/json'\n    },\n    body: JSON.stringify({\n      principal_id: user.uid,\n      delegate_id: 'agent-runner',  // FlowPilot's AI agent ID\n      workflow_id: workflow.workflow_id,\n      scope: ['execute'],\n      expires_in_days: 7\n    })\n  }\n);\n</code></pre>"},{"location":"getting-started/integration/#step-5-execute-workflow-via-agent","title":"Step 5: Execute Workflow via Agent","text":"<p>Trigger the AI agent to execute the workflow:</p> <pre><code>const runResponse = await fetch(\n  'https://flowpilot-ai-agent-api-737191827545.us-central1.run.app/v1/workflow-runs',\n  {\n    method: 'POST',\n    headers: {\n      'Authorization': `Bearer ${idToken}`,\n      'Content-Type': 'application/json'\n    },\n    body: JSON.stringify({\n      workflow_id: workflow.workflow_id,\n      principal_sub: user.uid,\n      dry_run: false,\n      persona: 'traveler'\n    })\n  }\n);\n\nconst runResult = await runResponse.json();\n\n// Check results\nrunResult.results.forEach(item =&gt; {\n  console.log(`Item ${item.workflow_item_id}: ${item.decision}`);\n  if (item.decision === 'deny') {\n    console.log('Reason:', item.reason_codes);\n  }\n});\n</code></pre>"},{"location":"getting-started/integration/#step-6-handle-authorization-decisions","title":"Step 6: Handle Authorization Decisions","text":"<p>The agent returns structured authorization decisions:</p> <pre><code>{\n  \"decision\": \"deny\",\n  \"reason_codes\": [\"rego.deny.consent_required\"],\n  \"advice\": [\n    {\n      \"type\": \"deny\",\n      \"message\": \"User consent not provided for auto-booking\"\n    }\n  ]\n}\n</code></pre>"},{"location":"getting-started/integration/#common-reason-codes","title":"Common Reason Codes","text":"Reason Code Meaning <code>rego.deny.consent_required</code> User hasn't consented to auto-booking <code>rego.deny.price_exceeded</code> Item price exceeds user's threshold <code>rego.deny.leadtime_exceeded</code> Booking too far in advance <code>rego.deny.risk_exceeded</code> Risk level too high for user <code>delegation.not_found</code> No delegation exists <code>delegation.expired</code> Delegation has expired"},{"location":"getting-started/integration/#complete-example","title":"Complete Example","text":"<p>Here's a complete workflow in JavaScript:</p> <pre><code>import { initializeApp } from 'firebase/app';\nimport { getAuth, signInWithEmailAndPassword } from 'firebase/auth';\n\n// 1. Initialize Firebase\nconst app = initializeApp(firebaseConfig);\nconst auth = getAuth(app);\n\n// 2. Sign in user\nconst userCredential = await signInWithEmailAndPassword(auth, email, password);\nconst idToken = await userCredential.user.getIdToken();\n\n// 3. Create workflow\nconst workflowResponse = await fetch(\n  'https://flowpilot-domain-services-api-737191827545.us-central1.run.app/v1/workflows',\n  {\n    method: 'POST',\n    headers: {\n      'Authorization': `Bearer ${idToken}`,\n      'Content-Type': 'application/json'\n    },\n    body: JSON.stringify({\n      template_id: 'trip-to-milan',\n      principal_sub: userCredential.user.uid,\n      start_date: '2026-02-01',\n      persona: 'traveler'\n    })\n  }\n);\nconst workflow = await workflowResponse.json();\n\n// 4. Delegate to agent\nawait fetch(\n  'https://flowpilot-delegation-api-737191827545.us-central1.run.app/v1/delegations',\n  {\n    method: 'POST',\n    headers: {\n      'Authorization': `Bearer ${idToken}`,\n      'Content-Type': 'application/json'\n    },\n    body: JSON.stringify({\n      principal_id: userCredential.user.uid,\n      delegate_id: 'agent-runner',\n      workflow_id: workflow.workflow_id,\n      expires_in_days: 7\n    })\n  }\n);\n\n// 5. Execute via agent\nconst runResponse = await fetch(\n  'https://flowpilot-ai-agent-api-737191827545.us-central1.run.app/v1/workflow-runs',\n  {\n    method: 'POST',\n    headers: {\n      'Authorization': `Bearer ${idToken}`,\n      'Content-Type': 'application/json'\n    },\n    body: JSON.stringify({\n      workflow_id: workflow.workflow_id,\n      principal_sub: userCredential.user.uid,\n      dry_run: false\n    })\n  }\n);\nconst result = await runResponse.json();\n\nconsole.log('Execution results:', result);\n</code></pre>"},{"location":"getting-started/integration/#sdk-support","title":"SDK Support","text":"<p>Currently, FlowPilot provides REST APIs. SDKs are planned for:</p> <ul> <li>JavaScript/TypeScript (coming soon)</li> <li>Swift/iOS (coming soon)</li> <li>Kotlin/Android (coming soon)</li> <li>Python (coming soon)</li> </ul> <p>For now, use standard HTTP clients in your language of choice.</p>"},{"location":"getting-started/integration/#rate-limits","title":"Rate Limits","text":"<ul> <li>Development: 100 requests/minute</li> <li>Production: 1000 requests/minute</li> <li>Enterprise: Custom limits</li> </ul> <p>Contact us for higher limits.</p>"},{"location":"getting-started/integration/#support","title":"Support","text":"<ul> <li>Documentation: API Reference</li> <li>Email: support@flowpilot.dev</li> <li>Discord: Join our community</li> </ul>"},{"location":"getting-started/integration/#next-steps","title":"Next Steps","text":"<ul> <li>Understand Personas - Learn about multi-persona authorization</li> <li>Writing Custom Policies - Create policies for your use case</li> <li>API Reference - Explore all available APIs</li> </ul>"}]}